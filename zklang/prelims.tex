\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage{geometry}
\usepackage{amssymb,amsthm,amsmath,amsfonts,longtable,comment,array,ifpdf,hyperref,url}
\usepackage{graphicx}

\title{Preliminaries}
\author{Lovesh Harchandani}
\date{5th January 2018, version 0.1}

\begin{document}

\maketitle

\section{Terminology}

Some preliminary concepts need to be defined; a basic understanding of set theory and number theory is required, set theory~\footnote{\url{https://en.wikipedia.org/wiki/Set-builder_notation}, \url{https://www.tutorialspoint.com/discrete_mathematics/discrete_mathematics_relations.htm}, \url{https://www.tutorialspoint.com/discrete_mathematics/discrete_mathematics_functions.htm}} and group theory~\footnote{\url{https://www.tutorialspoint.com/discrete_mathematics/discrete_mathematics_group_theory.htm}} is required. 
\newline

Throughout, $\mathbb{G}$ will always denote a finite multiplicative group with  \(\tau\)-bit prime order \emph{q} and a fixed generator \emph{g}\(\in\)$\mathbb{G}$ and $\mathbb{G}^{*}$ = $\mathbb{G}$ \ensuremath{\backslash} \{1\} will refer to its subset of non-identity elements. Likewise, $\mathbb{Z}_q$ will denote the field of integers modulo \emph{q}, and $\mathbb{Z}^{*}_q$ = $\mathbb{Z}_q$ \ensuremath{\backslash} \{0\} will refer to its multiplicative group of units.
\newline
\newline
If \(\Lambda\) is a finite set, then the set of all length-n sequences of elements from \(\Lambda\) is denoted by \(\Lambda^n\) and the set of all finite sequences (of any finite, non-negative length) of elements from \(\Lambda\) is denoted by \(\Lambda^{*}\) = \( \bigcup_{n\in\mathbb{N}} \)\(\Lambda^n\). The sequences in \(\Lambda^{*}\) are called finite strings over the alphabet \(\Lambda\) and subsets of \(\Lambda^{*}\) are called languages of strings over \(\Lambda\). Let \textit{S} and \textit{W} be arbitrary languages over \(\Lambda\). A collection of ordered pairs \textit{R} \(\subseteq\) \textit{S} \(\times\) \textit{W} is a (binary) relation on strings from \(\Lambda^{*}\). We call the language of strings \textit{$L_R$} {=} \{ \textit{s} $\in$ \textit{S} \(\mid\) \(\exists\)w $\in$ \textit{W}, \textit{(s, w)} $\in$ \textit{R} \} the language induced by \textit{R}. We treat \textit{R(s , w)} as a function evaluating to 1 if \textit{(s, w)} $\in$ \textit{R} and to 0 otherwise. If \textit{R(s, w)} = 1, then the string w is called a witness that s $\in$ \textit{$L_R$}. Given a string s $\in$ S, the set \textit{$W_R$(s)} {=} \{ \textit{s} w $\in$ W \(\mid\) \textit{R(s, w)} {=} 1 \} is called the witness set for s $\in$ \textit{$L_R$}. Of course, \textit{$W_R$(s)} = \{\} if s $(\notin)$ \textit{$L_R$}.
\newline
An algorithm whether it be deterministic or probabilistic is efficient if its expected running time is polynomial in the length of its inputs.
\newline
Throughout, we assume that there are efficient algorithms to test membership of arbitrary strings in \textit{S} and \textit{W} so that identifying instances for \textit{R} is easy. 
\newline
We make no assumptions about the ease or difficulty of testing membership of a string s in \textit{L\textsubscript{R}} when no appropriate witness w $\in$ \textit{W\textsubscript{R}(s)} has been provided.
\newline
\newline
\textit{NP-relations and NP-languages}. A language \textit{$L_R$} is called an NP-language if it belongs to the complexity class NP; that is, if (i) there exists an efficient algorithm to evaluate \textit{R(s, w)} on any instance \textit{(s,w)} $\in$ \textit{S ($\times$) W}, and (ii) there exists a polynomial time function \emph{p(n)} such that every s $\in$ \textit{$L_R$} has at least one witness w $\in$ \textit{$W_R$(s)} satisfying $|w|\leq p(|s|)$.
Any witness w $\in$ \textit{$W_R$(s)} that satisfies the latter bound is called an NP-witness that s $\in$ \textit{$L_R$} . If \textit{$L_R$} is an NP-language, then we call the relation R an NP-relation. Viewing \textit{$W_R$(s)} as the set of proofs that s $\in$ \textit{$L_R$}, we can interpret NP as the class of languages whose strings each have one or more "short" proofs of membership that can be checked in polynomial time.
\newline
\newline
\textit{Interactive protocols}. A protocol is a system of rules describing the sequence, syntax, and semantics of message exchange between two or more interactive algorithms where each exchange is called a move and 2 consecutive moves constitute a round. Protocols comprising just one move are called non-interactive protocols and those comprising two or more moves are called interactive protocols. We will be dealing with two-party protocols called interactive proof systems, which involve a pair of interactive algorithms that play two distinct roles: one algorithm is the prover and the other algorithm is the verifier. The "honest" prover and verifier algorithms are denoted by P and V respectively, potential "dishonest" impostors, \textit{$P^{*}$} and \textit{$V^{*}$} denote arbitrary algorithms taking on the prover and verifier roles in the protocol 
\newline

\end{document}
