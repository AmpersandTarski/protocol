\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage{geometry}
\usepackage{amssymb,amsthm,amsmath,amsfonts,longtable,comment,array,ifpdf,hyperref,url}
\usepackage{graphicx}

\newcommand{\quotes}[1]{``#1''}

\title{Background}
\author{Lovesh Harchandani}
\date{5th January 2018, version 0.1}

\begin{document}

\maketitle

This document is based on Efficient Zero-Knowledge Proofs and Applications \footnote{\url{https://uwspace.uwaterloo.ca/bitstream/handle/10012/8621/Henry_Ryan.pdf
}}
 

\section{Terminology}

\textit{Some preliminary concepts need to be defined; a basic understanding of set theory \footnote{\url{https://en.wikipedia.org/wiki/Set-builder_notation}\newline \url{https://www.tutorialspoint.com/discrete_mathematics/discrete_mathematics_relations.htm}\newline \url{https://www.tutorialspoint.com/discrete_mathematics/discrete_mathematics_functions.htm}}, modular arithematic\footnote{\url{https://en.wikipedia.org/wiki/Modular_arithmetic}} and group theory~\footnote{\url{https://www.di-mgt.com.au/multiplicative-group-mod-p.html}} is required.} 
\newline
Throughout, $\mathbb{G}$ will always denote a finite multiplicative group with \(\tau\)-bit prime order \emph{q} (\emph{q} is prime with \(\tau\) bits so $ 2^{\tau - 1} <= q < 2^{\tau} $) and a fixed generator \emph{g}\(\in\)$\mathbb{G}$ and $\mathbb{G}^{*}$ = $\mathbb{G}$ \ensuremath{\backslash} \{1\} will refer to its subset of non-identity elements (order \emph{q-1}). Likewise, $\mathbb{Z}_q$ will denote the field of integers modulo \emph{q} (order \emph{q}), and $\mathbb{Z}^{*}_q$ = $\mathbb{Z}_q$ \ensuremath{\backslash} \{0\} will refer to its multiplicative group of units (order \emph{q-1}).
\newline
\newline
If \(\Lambda\) is a finite set, then the set of all length-n sequences of elements from \(\Lambda\) is denoted by \(\Lambda^n\) and the set of all finite sequences (of any finite, non-negative length) of elements from \(\Lambda\) is denoted by \(\Lambda^{*}\) = \( \bigcup_{n\in\mathbb{N}} \)\(\Lambda^n\). The sequences in \(\Lambda^{*}\) are called finite strings over the alphabet \(\Lambda\) and subsets of \(\Lambda^{*}\) are called languages of strings over \(\Lambda\). Let \textit{S} and \textit{W} be arbitrary languages over \(\Lambda\). A collection of ordered pairs \textit{R} \(\subseteq\) \textit{S} \(\times\) \textit{W} is a (binary) relation on strings from \(\Lambda^{*}\). We call the language of strings \textit{$L_R$} {=} \{ \textit{s} $\in$ \textit{S} \(\mid\) \(\exists\)w $\in$ \textit{W}, \textit{(s, w)} $\in$ \textit{R} \} the language induced by \textit{R}. We treat \textit{R(s , w)} as a function evaluating to 1 if \textit{(s, w)} $\in$ \textit{R} and to 0 otherwise. If \textit{R(s, w)} = 1, then the string w is called a witness that s $\in$ \textit{$L_R$}. Given a string s $\in$ S, the set \textit{$W_R$(s)} = \{ \textit{w} $\in$ W $\mid$ \textit{R(s, w)} = 1 \}  is called the witness set for s $\in$ \textit{$L_R$}. Of course, \textit{$W_R$(s)} = \{\} if s $(\notin)$ \textit{$L_R$}.
\newline
An algorithm whether it be deterministic or probabilistic is efficient if its expected running time is polynomial in the length of its inputs.
\newline
Throughout, we assume that there are efficient algorithms to test membership of arbitrary strings in \textit{S} and \textit{W} so that identifying instances for \textit{R} is easy. 
\newline
We make no assumptions about the ease or difficulty of testing membership of a string s in \textit{L\textsubscript{R}} when no appropriate witness w $\in$ \textit{W\textsubscript{R}(s)} has been provided.
\newline
\newline
\textit{NP-relations and NP-languages}. A language \textit{$L_R$} is called an NP-language if it belongs to the complexity class NP\footnote{\url{https://stackoverflow.com/q/1857244}}; that is, if (i) there exists an efficient algorithm to evaluate \textit{R(s, w)} on any instance \textit{(s,w)} $\in$ \textit{S $\times$ W}, and (ii) there exists a polynomial time function \emph{p(n)} such that every s $\in$ \textit{$L_R$} has at least one witness w $\in$ \textit{$W_R$(s)} satisfying $|w|\leq p(|s|)$.
Any witness w $\in$ \textit{$W_R$(s)} that satisfies the latter bound is called an NP-witness that s $\in$ \textit{$L_R$} . If \textit{$L_R$} is an NP-language, then we call the relation R an NP-relation. Viewing \textit{$W_R$(s)} as the set of proofs that s $\in$ \textit{$L_R$}, we can interpret NP as the class of languages whose strings each have one or more \quotes{short} proofs of membership that can be checked in polynomial time.
\newline
\newline
\textit{Interactive protocols}. A protocol is a system of rules describing the sequence, syntax, and semantics of message exchange between two or more interactive algorithms where each exchange is called a move and 2 consecutive moves constitute a round. Protocols comprising just one move are called non-interactive protocols and those comprising two or more moves are called interactive protocols. We will be dealing with two-party protocols called interactive proof systems, which involve a pair of interactive algorithms that play two distinct roles: one algorithm is the prover and the other algorithm is the verifier. The \quotes{honest} prover and verifier algorithms are denoted by P and V respectively, potential \quotes{dishonest} impostors, \textit{$P^{*}$} and \textit{$V^{*}$} denote arbitrary algorithms taking on the prover and verifier roles in the protocol. If P is an interactive algorithm, then P(w) denotes P given the string w $\in$ \(\Lambda^{*}\) as its private auxiliary input. If V is a second interactive algorithm, then (P, V) denotes the protocol arising when P interacts with V, and $\langle$P, V$\rangle$(s) denotes the random variable describing the output of V in such an interaction when the common input string is s $\in$ S. P always makes the final move in an interactive proof, after which V checks one or more verification equations to decide whether it should accept or reject the interaction. $Pr[1 \gets \langle P, V \rangle (s)]$ denotes the probability that \quotes{V accepts} and $Pr[0 \gets \langle P, V \rangle (s)]$ denotes the probability that \quotes{V rejects}
\newline
Subsequent definitions assume an alphabet \(\Lambda\), S and W as infinite subsets of \(\Lambda^{*}\), an infinite relation $R \subseteq S \times W$ and an NP language \textit{$L_R$} 
\newline
\newline
\textit{Interactive proof}. Protocol (P, V) is an interactive proof system for R if there exists a negligible function \(\epsilon\) : $\mathbb{N}$ \(\to\) $\mathbb{R}^{+}$ such that, for every s $\in$ S and for every prover \textit{$P^{*}$}, (P, V) provides the following two guarantees.
\begin{enumerate}
  \item \textbf{Complete:}  If s $\in$ \textit{$L_R$}, then $Pr[1 \gets \langle P, V \rangle (s)] = 1$.
  \item \textbf{Sound:}  If s $(\notin)$ \textit{$L_R$}, then $Pr[1 \gets \langle P^{*}, V \rangle (s)] \le \epsilon(|s|)$.
\end{enumerate}
\textit{Interactive arguments}. It is useful to assume that \textit{$P^{*}$} is PPT\footnote{\url{https://crypto.stackexchange.com/q/8624}} in the common input, in which case we must modify the completeness criterion to provide honest P with an appropriate witness as private auxiliary input. The The interpretation of the soundness criterion also changes when we restrict \textit{$P^{*}$} to be PPT: for any sufficiently long common input s $\in$ S \ensuremath{\backslash} \textit{$L_R$} , it is computationally infeasible for \textit{$P^{*}$} to make V accept with a non-negligible probability.
\begin{enumerate}
  \item \textbf{Complete:}  If \textit{R(s, w)} = 1, then $Pr[1 \gets \langle P(w), V \rangle (s)] = 1$.
  \item \textbf{Sound:}  If s $(\notin)$ \textit{$L_R$}, then $Pr[1 \gets \langle P^{*}, V \rangle (s)] \le \epsilon(|s|)$.
\end{enumerate}
\textit{Knowledge extraction}. An algorithm E is called an extractor if given s and special access to \textit{$P^{*}$} as an oracle, can efficiently compute a witness w $\in$ \textit{W\textsubscript{R}(s)}. Consider a probabilistic algorithm $E_{P^{*}}$ endowed with rewinding black box oracle access to \textit{$P^{*}$}, meaning it can (i) send arbitrary messages to \textit{$P^{*}$} and read the responses \textit{$P^{*}$} generates  (ii) \quotes{rewind} \textit{$P^{*}$} to any earlier internal state (iii) is not privy to \textit{$P^{*}$}’s private inputs or internal state. Such a probabilistic algorithm $E_{P^{*}}$ is called an oracle machine for \textit{$P^{*}$}. If the ability for \textit{$P^{*}$} to make V accept with a probability non-negligible in $|s|$ implies that $E_{P^{*}}$ is an efficient algorithm for computing a witness \textit{w'} $\in$ \textit{$W_R$(s)}, then we say that an accepting proof or argument that s $\in$ \textit{$L_R$} implies \textit{$P^{*}$} knows a witness \textit{w} $\in$ \textit{$W_R$(s)}.
\newline
Protocol (P, V) is a system for proofs of knowledge for \textit{$L_R$} if there exists an oracle machine E, a positive function \(\kappa\) : $\mathbb{S}$ \(\to\) $\mathbb{R}^{+}$, and a constant a $\in$ $\mathbb{R}^{+}$ such that, for every prover \textit{$P^{*}$} the following are true
\begin{enumerate}
  \item \textbf{Complete:}  If s $\in$ \textit{$L_R$}, then $Pr[1 \gets \langle P, V \rangle (s)] = 1$.
  \item \textbf{Extractable::}  Let \(\rho\)(s) = $Pr[1 \gets \langle P^{*}, V \rangle (s)]$. If $\rho(s) > \kappa(s)$, then $E_{P^{*}}$ outputs a witness \textit{w'} $\in$ \textit{$W_R$(s)} in an expected number of steps at most $ |s|^{a} / (\rho(s) - \kappa(s)) $.
\end{enumerate}
An oracle machine E satisfying the above extractability criterion is called a universal knowledge extractor and the smallest function \(\kappa\)(·) for which the extractability criterion holds  is called the knowledge error function for (P, V). The knowledge error function measures the probability with which a dishonest \textit{$P^{*}$} can make V accept on input s $\in$ S without actually knowing a witness w $\in$ \textit{$W_R$(s)}, if \textit{$P^{*}$} causes honest V to accept with a probability non-negligibly greater than \(\kappa\)(s), then $E_{P^{*}}$ efficiently extracts a witness \textit{w} $\in$ \textit{$W_R$(s)}.
\newline
\textit{Zero-knowledge proofs}. Informally, an interactive proof system for \textit{$L_R$} is zero-knowledge if a trusted oracle merely proclaiming that s $\in$ \textit{$L_R$} enables any \textit{$V^{*}$} to efficiently deduce anything it might have \quotes{learned} by engaging in (P, ${V^{*}}$) on common input s $\in$ \textit{$L_R$}. A given verifier ${V^{*}}$ gains zero (extra) knowledge if, without any help from P, ${V^{*}}$ can \quotes{simulate} an interaction that is \quotes{indistinguishable} from the real interactions that occur when an honest P executes the protocol with that particular ${V^{*}}$ on the same common input. Thus there is no PPT cheating strategy using which ${V^{*}}$ can \quotes{learn} things from P that it could not just as easily compute on its own given the common input s and a promise that s $\in$ \textit{$L_R$}.
\newline
For a protocol execution between P and ${V^{*}}$: 
\begin{itemize}
  \item A \emph{transcript} is the tuple of messages exchanged between P and ${V^{*}}$ up until ${V^{*}}$ halts. 
  \item An \emph{accepting transcript} is a transcript of an accepting proof and a \emph{rejecting transcript} is a transcript of a rejecting proof.
  \item The \emph{aggregate view} of ${V^{*}}$ upon interacting with P, denoted $View_{P,V^{*}}(s)$, consists of all the information that ${V^{*}}$ \quotes{sees} in the protocol execution, including (i) the transcript, (ii) the common input string s (iii) ${V^{*}}$’s own private inputs (iv) ${V^{*}}$’s random coin flips  
  \item By parameterizing over all possible protocol executions for the same common input s but different random flips of ${V^{*}}$, we obtain a collection ${ View_{P,V^{*}}(s)}_{s \in L_R }$ of random variables called the \emph{ensemble}.
\end{itemize}
A two-party interactive protocol (P, V) is zero-knowledge on \textit{$L_R$} if, for every verifier ${V^{*}}$ and for every auxiliary string \textit{z} $\in$ \(\Lambda^n\), there exists an expected PPT algorithm $S_{V^{*}}$ such that the ensembles ${ View_{P,V^{*}}(s)}_{s \in L_R }$ and ${S_{V^{*}}(s,z)}_{s \in L_R }$ are indistinguishable. An algorithm $S_{V^{*}}$ with this property is called a simulator for ${V^{*}}$. \textit{z} is the prior knowledge of ${V^{*}}$, the idea is that for $S_{V^{*}}$ to have access to any data ${V^{*}}$ has access to. 
\newline
\textit{ Camenisch-Stadler notation}. The notation is used to denote systems for honest-verifier (verifier always chooses random values when it is supposed to and does not try to act on previously seen values) zero-knowledge proofs of knowledge.
\begin{itemize}
  \item $PK\{w : R(s,w) = 1\}$ denotes an honest-verifier zero-knowledge proof (or argument) of knowledge of a witness \textit{w} $\in$ \textit{$W_R$(s)}. By convention, any values that appear to the left of the colon constitute a witness that ${P^{*}}$ is proving knowledge of, and any values that appear only to the right of the colon are public.
  \item An interactive proof system (P, V) is called \emph{public coin} if the messages that honest V sends to P on common input \textit{s} $\in$ \textit{S} contain only uniform random strings from some publicly known \quotes{challenge} domain \textit{C(s)} 
  \item \emph{Fiat-Shamir Transform}: To convert a public coin system of Interactive Honest Verifier Zero Knowledge (IHVZK) proofs, replace \textit{V} with cryptographically secure hash function $H_s$ with range \textit{C(s)}. Whenever in IHVZK \textit{V} sends a random message, in Non Interactive Honest Verifier Zero Knowledge (NIHVZK), \textit{P} computes a random message by evaluating $H_s$ on the entire transcript until the current move. This is the \emph{Fiat-Shamir Transform}. Also \textit{V} can start the transcript with a random nonce $M$ forcing \textit{P} to compute a new proof every time and preventing \textit{P} to use any previously used proofs.
  \item $SPK\{w : R(s,w) = 1\}(M)$ is the non-interactive form of $PK\{w : R(s,w) = 1\}$ using \emph{Fiat-Shamir Transform} and the nonce $M$. SPK stands for signature proofs of knowledge since an accepting transcript with common input s and $M$ can be seen as P's signature over $M$ where witness \textit{w} $\in$ \textit{$W_R$(s)} is the private key. 
\end{itemize}
\end{document}
