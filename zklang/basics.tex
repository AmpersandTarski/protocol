\documentclass[a4paper]{article}

  \usepackage[utf8]{inputenc}
  \usepackage{geometry}
  \usepackage{amssymb,amsthm,amsmath,amsfonts,longtable,comment,array,ifpdf,hyperref,url}
  \usepackage{graphicx}
  
  \title{Zero Knowledge Language}
  \author{Michael Lodder}
  \date{4th January 2018, version 0.1}
  
  \begin{document}
  
  \maketitle
  
  \section{Introduction}
  
  Currently there exists many different methods for describing zero knowledge proofs in cryptographic mathematical notation. Zero Knowledge Language or ZKLang attempts to create a formal language to describe basic programmer mappings of zero knowledge proofs to complex cryptographic algorithms.~\footnote{\url{https://docs.google.com/presentation/d/1Zt1oRXASoKo03mnDpG7kNhjMDv6v4GhfIPNO6_aTEYM/edit?usp=sharing}}
  
  \section{Terminology}
  
  Before understanding zero knowledge proof, some preliminary concepts need to be defined; a basic understanding of set theory and number theory is required, set theory~\footnote{\url{https://en.wikipedia.org/wiki/Set-builder_notation}, \url{https://www.tutorialspoint.com/discrete_mathematics/discrete_mathematics_relations.htm}, \url{https://www.tutorialspoint.com/discrete_mathematics/discrete_mathematics_functions.htm}} and group theory~\footnote{\url{https://www.tutorialspoint.com/discrete_mathematics/discrete_mathematics_group_theory.htm}} is required. 
  \newline
  
  Throughout, $\mathbb{G}$ will always denote a finite multiplicative group with  \(\tau\)-bit prime order \emph{q} and a fixed generator \emph{g}\(\in\)$\mathbb{G}$ and $\mathbb{G}^{*}$ = $\mathbb{G}$ \ensuremath{\backslash} \{1\} will refer to its subset of non-identity elements. Likewise, $\mathbb{Z}_q$ will denote the field of integers modulo \emph{q}, and $\mathbb{Z}^{*}_q$ = $\mathbb{Z}_q$ \ensuremath{\backslash} \{0\} will refer to its multiplicative group of units.
  \newline
  \newline
  If \(\Lambda\) is a finite set, then the set of all length-n sequences of elements from \(\Lambda\) is denoted by \(\Lambda^n\) and the set of all finite sequences (of any finite, non-negative length) of elements from \(\Lambda\) is denoted by \(\Lambda^{*}\) = \( \bigcup_{n\in\mathbb{N}} \)\(\Lambda^n\). The sequences in \(\Lambda^{*}\) are called finite strings over the alphabet \(\Lambda\) and subsets of \(\Lambda^{*}\) are called languages of strings over \(\Lambda\). Let \textit{S} and \textit{W} be arbitrary languages over \(\Lambda\). A collection of ordered pairs \textit{R} \(\subseteq\) \textit{S} \(\times\) \textit{W} is a (binary) relation on strings from \(\Lambda^{*}\). We call the language of strings \textit{$L_R$} {=} \{ \textit{s} $\in$ \textit{S} \(\mid\) \(\exists\)w $\in$ \textit{W}, \textit{(s, w)} $\in$ \textit{R} \} the language induced by \textit{R}. We treat \textit{R(s , w)} as a function evaluating to 1 if \textit{(s, w)} $\in$ \textit{R} and to 0 otherwise. If \textit{R(s, w)} = 1, then the string w is called a witness that s $\in$ \textit{$L_R$}. Given a string s $\in$ S, the set \textit{$W_R$(s)} {=} \{ \textit{s} w $\in$ W \(\mid\) \textit{R(s, w)} {=} 1 \} is called the witness set for s $\in$ \textit{$L_R$}. Of course, \textit{$W_R$(s)} = \{\} if s $(\notin)$ \textit{$L_R$}.
  \newline
  An algorithm whether it be deterministic or probabilistic is efficient if its expected running time is polynomial in the length of its inputs.
  \newline
  Throughout, we assume that there are efficient algorithms to test membership of arbitrary strings in \textit{S} and \textit{W} so that identifying instances for \textit{R} is easy. 
  \newline
  We make no assumptions about the ease or difficulty of testing membership of a string s in \textit{L\textsubscript{R}} when no appropriate witness w $\in$ \textit{W\textsubscript{R}(s)} has been provided.
  \newline
  \newline
  \textit{NP-relations and NP-languages}. A language \textit{$L_R$} is called an NP-language if it belongs to the complexity class NP; that is, if (i) there exists an efficient algorithm to evaluate \textit{R(s, w)} on any instance \textit{(s,w)} $\in$ \textit{S ($\times$) W}, and (ii) there exists a polynomial time function \emph{p(n)} such that every s $\in$ \textit{$L_R$} has at least one witness w $\in$ \textit{$W_R$(s)} satisfying $|w|\leq p(|s|)$.
  Any witness w $\in$ \textit{$W_R$(s)} that satisfies the latter bound is called an NP-witness that s $\in$ \textit{$L_R$} . If \textit{$L_R$} is an NP-language, then we call the relation R an NP-relation. Viewing \textit{$W_R$(s)} as the set of proofs that s $\in$ \textit{$L_R$}, we can interpret NP as the class of languages whose strings each have one or more "short" proofs of membership that can be checked in polynomial time.
  \newline
  \newline
  \textit{Interactive protocols}. A protocol is a system of rules describing the sequence, syntax, and semantics of message exchange between two or more interactive algorithms where each exchange is called a move and 2 consecutive moves constitute a round. Protocols comprising just one move are called non-interactive protocols and those comprising two or more moves are called interactive protocols. We will be dealing with two-party protocols called interactive proof systems, which involve a pair of interactive algorithms that play two distinct roles: one algorithm is the prover and the other algorithm is the verifier. The "honest" prover and verifier algorithms are denoted by P and V respectively, potential "dishonest" impostors, \textit{$P^{*}$} and \textit{$V^{*}$} denote arbitrary algorithms taking on the prover and verifier roles in the protocol 
  \newline
  \newline
  ZKLang requires new terminology which should be easy to understand and expressive to write.
  \newline
  \newline
  \indent $\mathbb{Z}_p$: Multiplicative group modulo \emph{p}. \emph{p} is a prime. The basic rule for computations module a prime is to do the computations using the numbers as integers, but every time result \emph{r} is derived, compute it modulo \emph{p}. Taking the modulo means divide the result \emph{r} by \emph{p}, throw away the quotient, and keep the remainder as the answer. Mathematicians call the set of numbers modulo a prime \emph{p} a \emph{finite field} and often refer to it as "mod p". For example, \emph{p}=13 means the entire field is limited to modulo 13. If \emph{r}=38, then the answer in the group becomes $38\mod{13}=12$. \newline
  \newline
  \indent $\mathbb{Z}$\textbf{[g, p]}: Multiplicative group with generator \emph{g} modulo \emph{p}. \emph{g} generates the entire group and is called the \emph{primitive element} of the group. \emph{g} generates the set 1, \emph{g}, \emph{$g^2$},\dots,\emph{$g^{q-1}$} where \emph{$g^q$} = $1\mod{p}$. In other words, \emph{$g^q$} is the point where the numbers start to repeat. \emph{g} and \emph{p} are public.\newline
  \newline
  \indent \textbf{Comm}: Commitment. Hides a value, but ensures that it cannot be changed later. Given the parameters $\mathbb{Z}$[g, p], the statement \textbf{Comm(x)} means  $c=g^x\mod{p}$. The commitment scheme used for zero-knowledge proofs is the \emph{pedersen commitment scheme}. This is given as \textbf{Comm(x, y)} which means $c=g^xh^y\mod{p}$. In this equation, \emph{g} and \emph{h} and generators in \emph{p}, all three are known to all parties. Neither \emph{x} nor \emph{y} can be calculated from \emph{c}. \emph{x} and \emph{y} should chosen so \emph{c} is a prime number.\newline
  \newline
  
  \end{document}
  