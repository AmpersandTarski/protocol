%!TEX root =  IdmxSpecification.tex

\subsection{Concrete implementations of major building blocks}
\label{sec:blocks:major:impl}
In this section we describe the concrete implementations of the
major building blocks supported by the crypto architecture.

  For the sake of polymorphism (ensuring that most of the crypto engine
  is implementation-agnostic, thus enabling an easy addition of new
  implementations of a given building block), the concrete implementation may not
  expose any additional interface than that of the underlying abstract
  building block.


\subsubsection{Global System Parameter Generator}

\begin{description}
\item[Ecrypt-II Recommendations]
\identifier{i:spgen:ecrypt2011}

    This implementation uses the system parameter configuration template shown in Table \ref{tab:sysparam:conf}.
    The system parameters are generated based on the system parameter configuration file (filled out manually
    based on the template); the Ecrypt-II recommendations are used to determine the size of the groups,
    and the prime order groups are (if possible) taken from the NIST standard.
	\begin{table}[p]
	\centering
	    \begin{tabular}{|l|p{0.5\textwidth}|}\hline
	    \textbf{Field} & \textbf{Explanation} \\\hline
	    \identifier{sc:g:securitylevel}  & The overall security level for the system. The value is an integer, and corresponds to the security offered by a perfect symmetric cipher with a key length of the corresponding number of bits. \\\hline
	    \identifier{sc:g:attributelen}   & The length of the attributes in the system in bits.\\\hline
	    \identifier{sc:g:hashfunction}   & The URI of the hash function to be used throughout the system.\\\hline
	    \end{tabular}
	    \caption{System parameters configuration template for the Ecrypt-II system parameter generator.}
	    \label{tab:sysparam:conf}
	\end{table}
\end{description}

% ===========================================================================
% ===========================================================================
% ===========================================================================
\subsubsection{Privacy-ABC Signatures}

\begin{description}
\item[Camenisch-Lysyanskaya Signatures]
\identifier{i:sig:cl}

    This implementation uses the Camenisch-Lysyanskaya signature scheme over
    a group of signed quadratic residues modulo a safe RSA prime.

    The system parameter template generator does nothing.
    The system parameter generator creates the parameters described in Table \ref{tab:sysparam:cl}.
	\begin{table}[p]
	\centering
	    \begin{tabular}{|l|p{0.5\textwidth}|}\hline
	    \textbf{Field} & \textbf{Explanation} \\\hline
	    \identifier{sp:sig:cl:esize}  & The size in bits of the $e$ value in CL signatures.\\\hline
	    \identifier{sp:sig:cl:eprimesize}  & The size in bits of the $e'$ value in CL signatures.\\\hline
	    \identifier{sp:sig:cl:vsize}  & The size in bits of the $v$ value in CL signatures.\\\hline
	    \end{tabular}
	    \caption{System parameters generated by the Camenisch-Lysyanskaya implementation.}
	    \label{tab:sysparam:cl}
	\end{table}

    This implementation does not add any fields to the issuer key pair template.
    In addition to the fields described in Tables
    \ref{tab:issuerparam} and
    \ref{tab:issuerparamsec}, this implementation add the fields described in
    Tables \ref{tab:isskey:cl} and \ref{tab:isskey:cl:sec} to the issuer public
    and private keys.
	\begin{table}[p]
	\centering
	    \begin{tabular}{|l|p{0.5\textwidth}|}\hline
	    \textbf{Field} & \textbf{Explanation} \\\hline
	    \identifier{ip:cl:n}  & Safe RSA modulus used for the CL signature.\\\hline
	    \identifier{ip:cl:S}  & Base for randomizer of signature.\\\hline
	    \identifier{ip:cl:Z}  & Base for $e$ value of signature.\\\hline
	    \identifier{ip:cl:R:\emph{i}}  & (For $i$ from $1$ to \emph{attcount}) Base for $i$th attribute.\\\hline
	    \identifier{ip:cl:R:ext}  & (Optional) Base for external attribute (e.g., on smartcard).\\\hline
	    \identifier{ip:cl:R:cs}  & Base for the credential specification identifier.\\\hline
	    \end{tabular}
	    \caption{Additional fields in the issuer public key generated by the Camenisch-Lysyanskaya implementation.}
	    \label{tab:isskey:cl}
	\end{table}
	\begin{table}[p]
	\centering
	    \begin{tabular}{|l|p{0.5\textwidth}|}\hline
	    \textbf{Field} & \textbf{Explanation} \\\hline
	    \identifier{is:cl:p}  & First factor of $n$.\\\hline
	    \identifier{is:cl:q}  & Second factor of $n$.\\\hline
	    \end{tabular}
	    \caption{Additional fields in the issuer secret key generated by the Camenisch-Lysyanskaya implementation.}
	    \label{tab:isskey:cl:sec}
	\end{table}

    This implementation does not add any fields to the verifier
    parameter template. It adds the URI of this implementation as field
    (with no value) to the verifier parameters.

    \textbf{Key Generation.}
    The value $n$ is chosen to be a safe semi-prime of size \texttt{rsamodsize}.
    The bases $S$, $Z$, $\lbrace R_i \rbrace$, $R_\textrm{ext}$, $R_\textrm{cs}$ are chosen
    at random in the group of signed quadratic residues modulo $n$.

    \textbf{Issuance.}
    The issuer obtains a commitment $C=\prod_{i\in B}R_i^{m_i} \cdot S^r \cdot [R_\textrm{ext}^x \cdot S^k]$
    from the user (see \textbf{Carry over} below).
    Here $B$ is the set of user specified attributes, the part in square brackets is applicable
    only if the credential is bound to an external device, $x$ is the device secret key
    (of size $\texttt{attributelen}$) and $k$ is the credential secret key on the device
    (of size $\texttt{hashlen}+\texttt{attributelen}+\texttt{statisticalzk}$).
    Issuance from scratch means that $B=\emptyset$, $r=0$, and that no device is present.

    The attributes $\lbrace m_i \rbrace$ must be in the range 0..$2^{\texttt{attributelen}}-1$.

    The prime $e$ is computed as follows: choose a random number $e'$ of size
    $\texttt{eprimesize}$ (which is at least $\texttt{attributelen}+1$) until
    the value $e=e' + 2^{\texttt{esize}-1}$ is a prime (here \texttt{esize}
    is at least $\texttt{attributelen}+\texttt{hashlen}+\texttt{statisticalzk}+5$).
    A ``credential secret'' $w$ of length \texttt{vsize} (which is at least
    $\texttt{rsamodsize}+\texttt{attributelen}+\texttt{hashlen}+\texttt{statisticalzk}+3$)
    is chosen at random.

    The value $A$ is computed as follows (with the help of the factorization of $n$):
    \begin{align*}
    A \gets \left( \frac{Z}{C \cdot \prod_{i\in\neg B}{R_i^{m_i}}\cdot R_\textrm{cs}^t \cdot S^{w}} \right)^{1/e}
    =
    \left( \frac{Z}{\prod_{i}{R_i^{m_i}}\cdot R_\textrm{cs}^t [\cdot R_\textrm{ext}^x \cdot S^k] \cdot S^{w+r}} \right)^{1/e}
    \end{align*}
    here $t$ is the identifier of the credential specification (usually a hash of the credential specification).
    The signature consists of $(A, e, v)$ with $v=w+r$.
    The issuer proves to the user that the operation was done correctly (but this is a trivial proof,
    since all attributes are given to the user anyway): the user checks that
    $Z = A^e\cdot \prod_{i}{R_i^{m_i}}\cdot R_\textrm{cs}^t [\cdot R_\textrm{ext}^x \cdot S^k] \cdot S^{w+r}$,
    and that the values $\lbrace m_i\rbrace$, $e$, and $w$ are in the correct range.

    \textbf{Presentation.}
    The signature is first re-randomized by choosing $r$ at random of size $\texttt{rsamodsize}+\texttt{statisticalzk}$
    and letting $A'\gets A\cdot S^r$ and $v'=v-e\cdot r$. Let $e'=e-2^{\texttt{esize}-1}$.
    The user proves to the verifier that:
    $\mathit{PK}\lbrace (e', \lbrace m_i \rbrace, x, k, v'): Z = (A')^{(e'+ 2^{\texttt{esize}-1})}\cdot \prod_{i}{R_i^{m_i}}\cdot R_\textrm{cs}^t [\cdot R_\textrm{ext}^x \cdot S^k] \cdot S^{(v')}\rbrace$.
    In the proof, there is an implicit inexact range proof done on all attributes, i.e.,
    it is very improbable that a cheating prover can convince a verifier if he uses attributes
    that are more that $\texttt{challengesize}+\texttt{statisticalzk}$ bits longer than their
    usual range (in particular, the value $e=e' + 2^{\texttt{esize}-1}$ is thus guaranteed to be strictly larger than 1
    with overwhelming probability).

    In case an external device is present, it will perform the proof
    $\mathit{PK}\lbrace (x, k): C' = R_\textrm{ext}^x \cdot S^k\rbrace$ for the user,
    which the user then ``hijacks'' to prove the first equation to the issuer.

    \textbf{Carry over.}
    The user proves to the issuer that
    $\mathit{PK}\lbrace (\lbrace m_i\rbrace, x, k, r) : C=\prod_{i\in B}R_i^{m_i} \cdot S^r \cdot [R_\textrm{ext}^x \cdot S^k] \rbrace$
    here $C$ is transmitted to the issuer as part of the proof (it is a D-value).
    The attribute $r$ of size $\texttt{rsamodsize}+\texttt{statisticalzk}$ is chosen randomly.
    In case an external device is present, it will perform the proof
    $\mathit{PK}\lbrace (x, k): C' = R_\textrm{ext}^x \cdot S^k\rbrace$ for the user,
    which the user then ``hijacks'' to prove the first equation to the issuer.

    Be careful when carrying over attributes from a source that uses known-order groups (e.g., from Brands/U-Prove credentials),
    as the latter will not guarantee that the attributes will be in range 0..$2^{attributelen}-1$. It is
    recommended to add range proofs to all such attributes.

    The function getNumberOfAdditionalIssuanceRoundtrips() returns 0. The functions extraIssuanceRoundRecipient()
	 and extraIssuanceRoundIssuer() return null. The function extractSignature returns a credential based on the return value
	 of \textsf{ObtainSign} (Step 4).



\item[Brands Signatures]
\identifier{i:sig:uprove}

    This implementation uses Brands signatures as used in Microsoft Uprove.

    The system parameter template generator and system parameter generator do nothing.

    This implementation adds the fields described in
    Table \ref{tab:isskey:uprove:templ} to the issuer key pair template.
    In addition to the fields described in Tables
    \ref{tab:issuerparam} and
    \ref{tab:issuerparamsec}, this implementation adds the fields described in
    Tables \ref{tab:isskey:uprove} and \ref{tab:isskey:uprove:sec} to the issuer public
    and private keys.
	\begin{table}[p]
	\centering
	    \begin{tabular}{|l|p{0.4\textwidth}|}\hline
	    \textbf{Field} & \textbf{Explanation} \\\hline
	    \identifier{ic:uprove:tokens}  & Number of Uprove tokens to generate during issuance.\\\hline
	    \end{tabular}
	    \caption{Additional fields in the issuer key template generated by the Uprove implementation.}
	    \label{tab:isskey:uprove:templ}
	\end{table}
	\begin{table}[p]
	\centering
	    \begin{tabular}{|l|p{0.5\textwidth}|}\hline
	    \textbf{Field} & \textbf{Explanation} \\\hline
	    \identifier{ip:uprove:g:0}  & Public generator $g_0$.\\\hline
	    \identifier{ip:uprove:g:\emph{i}}  & (For $i$ from $1$ to \emph{attcount}) Public generator for $i$th attribute.\\\hline
	    \identifier{ip:uprove:g:ext}  & (Optional) Public generator for external attribute (e.g., on smartcard).\\\hline
	    \identifier{ip:uprove:g:t}  & Public generator $g_t$.\\\hline
	    \identifier{ip:uprove:z:0}  & Issuance value $z_0$.\\\hline
	    \identifier{ip:uprove:z:\emph{i}}  & (For $i$ from $1$ to \emph{attcount}) Issuance value for $i$th attribute.\\\hline
	    \identifier{ip:uprove:z:ext}  & (Optional) Issuance value for external attribute (e.g., on smartcard).\\\hline
	    \identifier{ip:uprove:z:t}  & Issuance value $z_t$.\\\hline
	    \identifier{ip:uprove:tokens}  & Number of Uprove tokens to generate during issuance.\\\hline
	    \end{tabular}
	    \caption{Additional fields in the issuer public key generated by the Uprove implementation.}
	    \label{tab:isskey:uprove}
	\end{table}
	\begin{table}[p]
	\centering
	    \begin{tabular}{|l|p{0.5\textwidth}|}\hline
	    \textbf{Field} & \textbf{Explanation} \\\hline
	    \identifier{is:uprove:y0}  & Private key $y_0$.\\\hline
	    \end{tabular}
	    \caption{Additional fields in the issuer secret key generated by the Uprove implementation.}
	    \label{tab:isskey:uprove:sec}
	\end{table}

    This implementation does not add any fields to the verifier
    parameter template. It adds the URI of this implementation as field
    (with no value) to the verifier parameters.

    The implementation is compatible with the latest version of the U-Prove specification \cite{brapaq10}.

    \textbf{Key generation.}
    See the U-Prove specification.

    \textbf{Issuance.}
    See the U-Prove specification.

    \textbf{Presentation.}
    See the U-Prove specification.

    Note that the crypto engine computes the hash contribution for Brands signature ZkModules differently than
    for other ZkModules, in order to ensure compatibility with the U-Prove spec.

    \textbf{Carry over.}
    The user proves to the issuer that
    $\mathit{PK}\lbrace (\lbrace m_i\rbrace, x, r) : C=\prod_{i\in B}g_i^{m_i} \cdot g^r \cdot [g_\textrm{D}^x] \rbrace$
    here $C$ is transmitted to the issuer as part of the proof (it is a D-value).
    The attribute $r$ is chosen randomly. Here $x$ is the device secret.
    In case an external device is present, it will perform the proof
    $\mathit{PK}\lbrace (x): C' = g_\textrm{D}^x$ for the user,
    which the user then ``hijacks'' to prove the first equation to the issuer.

    The function getNumberOfAdditionalIssuanceRoundtrips() returns 1.
    The function extraIssuanceRoundRecipient() peforms Step 4 and 5.
    The function extraIssuanceRoundIssuer() performs Step 6.
    The function extractSignature() performs Step 7 and returns a credential based on the return value of the step.

    This implementation generates a number of Uprove tokens at once (this number is taken
    from the system parameters), and returns each token as a separate "signature".
\end{description}

% ===========================================================================
% ===========================================================================
% ===========================================================================
\subsubsection{Inspection}

\begin{description}
\item[Camenisch-Shoup-03 Verifiable encryption]
\identifier{i:ins:cs03}

    This implementation uses the Camenisch-Shoup-03 Verifiable encryption scheme \cite{camsho03}.

    This implementation does not add any fields to the inspector key pair template.
    In addition to the fields described in Tables
    \ref{tab:inspar:pub} and
    \ref{tab:inspar:sec}, this implementation add the fields described in
    Tables \ref{tab:inspar:pub:cs} and \ref{tab:inspar:sec:cs} to the inspector public
    and private keys.
	\begin{table}[p]
	\centering
	    \begin{tabular}{|l|p{0.5\textwidth}|}\hline
	    \textbf{Field} & \textbf{Explanation} \\\hline
	    \identifier{ep:cs03:n}  & Safe RSA modulus used as modulus in the CS03 encryption.\\\hline
	    \identifier{ep:cs03:g}  & Generator.\\\hline
	    \identifier{ep:cs03:y:1}  & Base for message.\\\hline
	    \identifier{ep:cs03:y:2}  & First base for CCA-2 security.\\\hline
	    \identifier{ep:cs03:y:3}  & Second base for CCA-2 security.\\\hline
	    \end{tabular}
	    \caption{Additional fields in the inspector public key generated by the Camenisch-Shoup implementation.}
	    \label{tab:inspar:pub:cs}
	\end{table}
	\begin{table}[p]
	\centering
	    \begin{tabular}{|l|p{0.5\textwidth}|}\hline
	    \textbf{Field} & \textbf{Explanation} \\\hline
	    \identifier{es:cs03:order}  & The order of the group modulo $n$.\\\hline
	    \identifier{es:cs03:x:1}  & Discrete logarithm (relative to $g$) of $y_1$.\\\hline
	    \identifier{es:cs03:x:2}  & Discrete logarithm (relative to $g$) of $y_2$.\\\hline
	    \identifier{es:cs03:x:3}  & Discrete logarithm (relative to $g$) of $y_3$.\\\hline
	    \end{tabular}
	    \caption{Additional fields in the inspector secret key generated by the Camenisch-Shoup implementation.}
	    \label{tab:inspar:sec:cs}
	\end{table}

    This implementation does not add any fields to the verifier
    parameter template. It adds the URI of this implementation as field
    (with no value) to the verifier parameters.

    \textbf{Key generation.}
    The inspector chooses two safe semi-primes $n$ and $m$ of length \texttt{rsamodsize}.
    Let $g'$ be a random element modulo $n^2$, and $g\gets (g')^{2n}$.
    Choose $x_1, x_2, x_3$ at random in $0$..$n^2/4$.
    Let $y_i\gets g^{x_i}$. Let $h \gets (n+1)\pmod{n^2}$.
    Let $k$ be a random \texttt{securitylevel}-bit string.
    Let $p$ and $q$ be random generators in the group of signed quadratic residues modulo $m$.
    The public key is $(n, y_1, y_2, y_3, h, k, m, p, q)$.
    The secret key is $x_1, x_2, x_3$. Note that the factorization of $n$ and $m$ are not needed.

    \textbf{Encryption and presentation.}
    To encrypt $a$ under label $\ell$ do the following. Choose a random $r$ in 0..$n/4$.
    Let $u\gets g^r$, $e\gets y_1^r \cdot h^a$, $w\gets\hashfunction(\stringToBytes(k),\stringToBytes(u),\stringToBytes(e),\stringToBytes(\ell))$,
    $b\gets y_2\cdot y_3^{w}$, $v\gets |b^r|$. The ciphertext is $(u,e,v)$.
    Here $\hashfunction$ is the hash function defined in the security parameters,
    \stringToBytes is defined in Section~\ref{ssec:challenge:prelim},
    $|z|$ is defined to return a value in $-n^2/2+1..n^2/2$ such that $|z|\equiv z \pmod{n^2}$.

    To prove that an encryption was done correctly, the user chooses a random
    value $s$ of $\texttt{rsamodsize}+1+\texttt{statisticalzk}$ bits,
    sets $C=p^a\cdot q^s$, and does
    the following proof:
    \begin{align*}
    \mathit{PK}\lbrace (r, a, s):
    (u^2) = (g^2)^r \wedge
    (e^2) = (y_1^2)^r \cdot (h^2)^a \wedge
    (v^2) = (b^2)^r \wedge
    C = p^a \cdot q^s
    \rbrace.
    \end{align*}
    Here the verifier recomputes $b$ from $y_2, y_3, k, u, e, \ell$.

    \textbf{Decryption.}
    Re-compute $w$ from $k,u,e,\ell$.  Let $d \gets 2\cdot(x_2 + w\cdot x_3)$. Check that $u^d = v^2$ (otherwise fail).
    Let $t=2^{-1}\pmod{n}$, $\hat{a} = (e/u^{x_1})^{2t}$.
    One should have $\hat{a} = 1+a\cdot n \pmod{n^2}$ (otherwise fail), return $a$.

\end{description}

% ===========================================================================
% ===========================================================================
% ===========================================================================
\subsubsection{Revocation}

The Idmx library provides revocation where we currently have implemented one scheme 
using accumulators~\cite{camlys02a}.

\begin{description}
\item[Camenisch-Lysyanskaya Accumulators]
\identifier{revocation:cl}

    This implementation does not add any fields to the revocation authority key pair template.
    In addition to the fields described in Tables~\ref{tab:revpar:pub} and
    \ref{tab:revpar:sec}, this implementation adds the fields described in
    Tables \ref{tab:revpar:pub:cl} and \ref{tab:revpar:sec:cl} to the revocation authority public
    and private keys.
	\begin{table}[p]
	\centering
	    \begin{tabular}{|l|p{0.5\textwidth}|}\hline
	    \textbf{Field} & \textbf{Explanation} \\\hline
	    \identifier{rp:cl02:n}  & Safe RSA modulus used as modulus.\\\hline
	    \identifier{rp:cl02:g}  & First generator.\\\hline
	    \identifier{rp:cl02:h}  & Second generator.\\\hline
	    \end{tabular}
	    \caption{Additional fields in the revocation authority public key generated by the Camenisch-Lysyanskaya-02 implementation.}
	    \label{tab:revpar:pub:cl}
	\end{table}
	\begin{table}[p]
	\centering
	    \begin{tabular}{|l|p{0.5\textwidth}|}\hline
	    \textbf{Field} & \textbf{Explanation} \\\hline
	    \identifier{rs:cl02:order}  & The order of the group modulo $n$.\\\hline
	    \end{tabular}
	    \caption{Additional fields in the revocation authority secret key generated by the Camenisch-Lysyanskaya-02 implementation.}
	    \label{tab:revpar:sec:cl}
	\end{table}

    This implementation does not add any fields to the verifier
    parameter template. It adds the URI of this implementation as field
    (with no value) to the verifier parameters.

    \textbf{Key Generation.}
    Choose a same semi-prime $n$ of length \texttt{rsamodsize}.
    Choose two random bases $g$ and $h$ in the group of signed quadratic residues modulo $n$.
    The public key is $(n, g, h)$, the secret key is the factorization of $n$.

    \textbf{Empty accumulator.}
    Set $v\gets g$.

    \textbf{Add prime to accumulator.}
    Only random primes of length \texttt{attributelen} are added to the accumulator
    (this is also called the revocation handle).
    The value of the accumulator $v$ does not change when adding a prime to it.

    \textbf{Remove a prime from accumulator.}
    To remove a prime $e$ that was previously added, do (with the help of the secret key):
    $v\gets v^{1/e}$.

    \textbf{Calculate a witness from scratch.}
    The witness $w$ for a prime $e$ in the accumulator is calculated as follows
    (with the help of the secret key):
    $w\gets v^{1/e}$.

    \textbf{Update a witness.}
    To update a witness $w$ for a prime $e$ when removing a prime $p\neq e$
    from the accumulator do:
    find $a,b$ such that $a\cdot e + b\cdot p = 1$ using the extended Euclid algorithm;
    let $w\gets w^b \cdot v^a$, where $v$ is the new accumulator value.

    \textbf{Presentation.}
    To prove possession of a witness $w$ for prime $e$ (and hence, non-revocation of the
    revocation handle $e$), the user does as follows:
    choose $r_1, r_2, r_3$ at random of length $\texttt{rsamodsize}+1$,
    let $\textit{r2e}=r_2\cdot e$ and $\textit{r3e}=r_3\cdot e$,
    and $\textit{Cw}\gets w\cdot h^{r_2}$.
    The prover does the following proof:
    \begin{align*}
     \mathit{PK}\lbrace (e, r_1, r_2, r_3, \textit{r2e}, \textit{r3e}):
        \textit{Ce} = g^e \cdot h^{r_1} \wedge
        \textit{Cr} = g^{r_2} \cdot h^{r_3} \wedge\\
        v = \textit{Cw}^e \cdot (h^{-1})^{\textit{r2e}} \wedge
        1 = \textit{Cr}^e \cdot (g^{-1})^{\textit{r2e}}\cdot(h^{-1})^{\textit{r3e}}
     \rbrace.
    \end{align*}

\end{description}

% ===========================================================================
% ===========================================================================
% ===========================================================================
\subsubsection{Pseudonyms}
    
\begin{description}
\item[Idemix Scope-Exclusive Pseudonyms]
\identifier{i:nym:se:idmx}

    This implementation creates scope-exclusive pseudonyms, meaning that only
    a single pseudonym can be created for each pair of secret and scope.

    This implementation does not add any fields to the verifier
    parameter template. It adds the URI of this implementation as field
    (with no value) to the verifier parameters.

    This implementation derives pseudonyms in the following way:
    $P = S^x$ where $S=\operatorname{hash}(\textit{scope})^{(p-1)/q}\pmod{p}$.
    Here $x$ is the device secret, $p$ is \texttt{dhmodulus}, $q$ is \texttt{dhsubgrouporder},
    and $\operatorname{hash}$ is the hash function defined in the system parameters.

    During presentation, the device performs a proof of knowledge of the secret
    to the user $\mathit{PK}\lbrace(x): P = S^x\rbrace$, and the user hijkacks this proof to prove the same statement
    to the verifier.

\item[Non-Scope-Exclusive Pseudonyms Based On Pedersen Representation]
\identifier{i:nym:nse:pedersen}

    This implementation creates non-scope-exclusive pseudonyms, meaning that multiple
    pseudonyms can be created for each pair of secret and scope.

    This implementation does not add any fields to the verifier
    parameter template. It adds the URI of this implementation as field
    (with no value) to the verifier parameters.

    This implementation derives pseudonyms in the following way:
    $P=g^x \cdot h^r$, where $r$ is selected at random between $0$ and $(q-1)$.
    Here $x$ is the device secret, $q$ is \texttt{dhsubgrouporder},
    $g$ is \texttt{dhgen:0} and $h$ is \texttt{dhgen:1}.

    During presentation, the device performs the proof $\textit{PK}\lbrace (x): P' = g^x\rbrace$
    to the user.
    The user hijacks this proof to prove $\textit{PK}\lbrace (x, r): P = g^x \cdot h^r \rbrace$
    to the verifier.
\end{description}

% ===========================================================================
% ===========================================================================
% ===========================================================================
\subsubsection{Not-Equal Proofs}

\notimplemented

Not-equal proofs allow proving that an attribute does does not have a specific value.

% \begin{description}
% \item[Prove knowledge of an attribute's inverse]
% \identifier{i:ne:inv}
% 
%     This implementation proves knowledge of the inverse (modulo
%     \textit{dhsubgrouporder}) of the difference
%     between the two operands.
% 
%     This implementation does not add any fields to the verifier
%     parameter template. It adds the URI of this implementation as field
%     (with no value) to the verifier parameters.
% 
% 	\robert{TODO: add equations.}
% \end{description}
        
% ===========================================================================
% ===========================================================================
% ===========================================================================
\subsubsection{Inequality Proof}

Inequality proofs allow a user to prove that two attributes or constants $a$ and $b$
satisfy either $0\leq a < b \leq 2^{\texttt{attributelen}}-1$
or $0\leq a < b \leq 2^{\texttt{attributelen}}-1$.
Depending on the declared residue classes of $a$ and $b$, the proof engine might
skip the range checks $0\leq a$ and/or $b \leq 2^{\texttt{attributelen}}-1$ if
it thinks it is safe to do so.

These inequalities can be transformed into one or more inequalities of the form $\delta\geq 0$
(e.g., with $\delta = b-a$ or $\delta = b-a-1$). The proof engine will use linear combinations
of attributes to declare $\delta$.

\texttt{Proof that $\delta\geq 0$.}
The prover and verifier must agree on a safe semi-prime $n$ of length $\texttt{rsamodsize}$
and two generators $Z$ and $S$ of the group of signed quadratic residues modulo $n$,
such that the prover does not know the factorization of $n$. The proof engine re-uses
an issuer public key for the Camenisch-Lysyanskaya Privacy-ABC signature scheme for that purpose.

The prover decomposes $\delta=u_1^2+u_2^2+u_3^2+u_4^2$ using the Rabin-Shallit decomposition algorithm
(one could also use Lipmaa decomposition). The prover then chooses random values
$r_0, r_1, r_2, r_3, r_\delta$ of size $\texttt{rsamodsize}+\texttt{statisticalzk}$ and sets
$\alpha = r_\delta + \sum_j u_j\cdot r_j$ (of size at most $\texttt{attributelen}/2+\texttt{rsamodsize}+\texttt{statisticalzk}+3$).
Let $\lbrace C_j \gets Z^{u_j}\cdot (S^{-1})^{r_j} \rbrace_{j=0..3}$, $C_\delta \gets Z^\delta \cdot S^{r_\delta}$.
The prover proves to the verifier that:
\begin{align*}
\textit{PK}\lbrace (\delta, u_0, u_1, u_2, u_3, r_\delta, r_0, r_1, r_2, r_3, \alpha):\\
C_0 = Z^{u_0}\cdot (S^{-1})^{r_0} \wedge
C_1 = Z^{u_1}\cdot (S^{-1})^{r_1} \wedge
C_2 = Z^{u_2}\cdot (S^{-1})^{r_2} \wedge
C_3 = Z^{u_3}\cdot (S^{-1})^{r_3} \wedge\\
C_\delta = Z^{\delta}\cdot S^{r_\delta} \wedge
C_\delta = C_0^{u_0} \cdot C_1^{u_1} \cdot C_2^{u_2} \cdot C_3^{u_3} \cdot S^\alpha
\rbrace.
\end{align*}


% \begin{description}
% \item[Four-squares method]
% \identifier{i:ineq:4sq}
% 
%    This implementation does not add any fields to the verifier
%    parameter template. It adds the fields
%    described in table \ref{tab:ineq:4sq:param}
%    to the verifier parameters.
% 	\begin{table}[p]
% 	\centering
% 	    \begin{tabular}{|l|p{0.5\textwidth}|}\hline
% 	    \textbf{Field} & \textbf{Explanation} \\\hline
% 	    \identifier{i:ineq:4sq}  & (No value.) This fields shows that the verifier supports the four-square method for inequality proofs.\\\hline
% 	    \identifier{vp:ineq:4sq:n}  & A safe RSA modulus whose factorization is unknown to the provers.\\\hline
% 	    \identifier{vp:ineq:4sq:g}  & A generator of the signed quadratic residues modulo $n$.\\\hline
% 	    \identifier{vp:ineq:4sq:h}  & A generator of the signed quadratic residues modulo $n$, such
% 	    that its relative discrete logarithm to $g$ is unknown to the prover.\\\hline
% 	    \end{tabular}
% 	    \caption{Additional fields in the verifier parameters generated by the Four-Squares Inequality proof.}
% 	    \label{tab:ineq:4sq:param}
% 	\end{table}
% 
%     This implementation first transforms the problem into one where it
%     needs to prove that an attribute is larger-or-equal to zero
%     (by taking the difference of the operands, negating the value if necessary,
%     and removing one if necessary). It then expresses that new attribute as
%     the sum of four squares. Finally it proves that the attribute can be
%     expressed in that way.
% 
%     The proof interface for encryption might trigger the need for a Range check module,
%     to ensure that the attributes that were input are really in the proper range.
%     (A one-sided check might be enough).
% 	\robert{It might not be necessary to do a range check, but currently the ZkBuilder and
% 	zkVerifier lack proper interfaces for this optimization.}
% 
%     \robert{TODO: add equations.}
% \end{description}

% ===========================================================================
% ===========================================================================
% ===========================================================================
\subsubsection{Set Membership Proof} \notimplemented

% \begin{description}
% \item[Idemix set membership]
% \identifier{i:setmem:idmx1}
% 
%     This implementation works like the one-of attributes work
%     in Idemix (however, here the attribute can only be a single value among the
%     set of allowed values, and not a superposition of several values).
% 	 \robert{TODO: Add equations}
% 
% 	This implementation does not add any fields to the verifier
% 	parameter template. It adds the fields
% 	described in table \ref{tab:setmem:idmx:param}
% 	to the verifier parameters.
% 	\begin{table}[p]
% 	\centering
% 	    \begin{tabular}{|l|p{0.5\textwidth}|}\hline
% 	    \textbf{Field} & \textbf{Explanation} \\\hline
% 	    \identifier{i:setmem:idmx1}  & (No value.) This fields shows that the verifier supports the idemix set membership proofs.\\\hline
% 	    \identifier{vp:setmem:idmx1:n}  & A safe RSA modulus whose factorization is unknown to the provers.\\\hline
% 	    \identifier{vp:setmem:idmx1:g}  & A generator of the signed quadratic residues modulo $n$.\\\hline
% 	    \identifier{vp:setmem:idmx1:h}  & A generator of the signed quadratic residues modulo $n$, such
% 	    that its relative discrete logarithm to $g$ is unknown to the prover.\\\hline
% 	    \end{tabular}
% 	    \caption{Additional fields in the verifier parameters generated by the Idemix Set Membership proof.}
% 	    \label{tab:setmem:idmx:param}
% 	\end{table}
% \end{description}

% ===========================================================================
% ===========================================================================
% ===========================================================================
\subsubsection{Jointly-Random Attributes} \notimplemented

% \begin{description}
% \item[Groups of order close to $2^{\textit{attributelen}}$}]
% \identifier{i:jrand:close}
% 
%    This implementation does not add any fields to the verifier
%    parameter template. It adds the fields
%    described in Table \ref{tab:jrand:close:param}
%    to the verifier parameters.
% 	\begin{table}[p]
% 	\centering
% 	    \begin{tabular}{|l|p{0.4\textwidth}|}\hline
% 	    \textbf{Field} & \textbf{Explanation} \\\hline
% 	    \identifier{i:jrand:close}  & (No value.) This fields shows that the verifier supports the idemix set membership proofs.\\\hline
% 	    \identifier{vp:jrand:close:modulus}  & The modulus to use for the commitment in this implementation.\\\hline
% 	    \identifier{vp:jrand:close:grouporder}  & The order of \textit{modulus}.\\\hline
% 	    \identifier{vp:jrand:close:subgrouporder}  & The largest prime number that is smaller than $2^{\textit{attributelen}}$, also
% 	    the order of a subgroup of the group modulo \textit{modulus}.\\\hline
% 	    \identifier{vp:jrand:close:gen:0}  & A generator of order \textit{subgrouporder} of the group modulo \textit{modulus}. \\\hline
% 	    \identifier{vp:jrand:close:gen:1}  & A generator of order \textit{subgrouporder} of the group modulo \textit{modulus},
% 	    such that the relative discrete logarithm between the two generators is unknown to the recipient. \\\hline
% 	    \end{tabular}
% 	    \caption{Additional fields in the verifier parameters generated by the Jointly-Random Attributes Implementation based on groups
% 	    of order close to $2^{\textit{attributelen}}$.}
% 	    \label{tab:jrand:close:param}
% 	\end{table}
% 
%     This implementation is based on commitments in a group of order close to $2^{\textit{attributelen}}$ (but not larger,
%     for example groups of order $2^{256}-189$).
% 
%     This implementation needs 1 preliminary round of communication.
%     The recipient first commits to a
%     random value modulo \textit{subgrouporder} (using Pedersen commitment), and sends the commitment to the issuer.
%     The issuer saves that value and sends a random value modulo \textit{subgrouporder} to the recipient.
%     The recipient now proves that the newly created attribute is equal (modulo \textit{subgrouporder})
%     to the sum of the issuer's value and the value inside the commitment. The recipient also adds an
%     inequality proof that the value of the
%     attribute is between $0$ and $\textit{subgrouporder}-1$.
% 
%     \robert{TODO: add equations}
% \end{description}
