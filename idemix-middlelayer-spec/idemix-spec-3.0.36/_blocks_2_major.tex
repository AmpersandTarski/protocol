%!TEX root =  IdmxSpecification.tex

  \subsection{Major Building Blocks}
  \label{sec:blocks:major}
  
  In this section we list the major building blocks supported by our
  crypto architecture.
  All of the major building blocks are \emph{abstract} classes, as
  there may be several concrete implementations of the same functionality.

  The concrete instantiations of these building blocks are described in Section \ref{sec:blocks:major:impl}.
    \subsubsection{Global System Parameter Generator}
    \identifier{b:spgen}

    The global system parameter generator is responsible for generating some of the
    system parameters: namely the ones used by a majority of the building blocks,
    such as the size of discrete logarithm
    and RSA-type groups, the security parameters of the zero-knowledge proofs,
    the parameters of one prime order group,
    etc.

    This building block has the following interfaces:
    the ones described in Sections~\ref{sec:intf:all} and \ref{sec:intf:major},
    and a system parameter generator (Section \ref{sec:intf:syspargen}).
    We now describe the system parameter generator in more detail.

    \paragraph{System parameter generator.}
    This block must generate the system parameters described in Table \ref{tab:sysparam}.

\begin{table}[p]
\centering
    \begin{tabular}{|l|p{0.5\textwidth}|}\hline
    \textbf{Field} & \textbf{Explanation} \\\hline
    \identifier{sp:g:spuid}  & The unique UID given to these system parameters. \\\hline
    \identifier{sp:g:securitylevel}  & The overall security level for the system. The value is an integer, and corresponds to the security offered by a perfect symmetric cipher with a key length of the corresponding number of bits. \\\hline
    \identifier{sp:g:attributelen}   & The length of the attributes in the system in bits.\\\hline
    \identifier{sp:g:hashfunction}   & The URI of the hash function to be used throughout the system.\\\hline
    \identifier{sp:g:dhmodsize}      & The size of the modulus of a prime order groups in bits.\\\hline
    \identifier{sp:g:dhsubgroupsize} & The size of the prime order subgroups in bits. \\\hline
    \identifier{sp:g:dhmodulus}      & The modulus to use for prime order groups (BigInteger). \\\hline
    \identifier{sp:g:dhgrouporder}   & The order of dhmodulus (BigInteger).\\\hline
    \identifier{sp:g:dhsubgrouporder}& The prime order of a large subgroup of the group modulo dhmodulus (BigInteger).\\\hline
    \identifier{sp:g:dhgen:0}       & A generator of order dhsubgrouporder of the group modulo dhmodulus (BigInteger).\\\hline
    \identifier{sp:g:dhgen:1}       & Another generator of the same group, such that the relative discrete logarithm between the two generators is unknown.\\\hline
    \identifier{sp:g:rsamodsize}     & The size of the modulus of an RSA group in bits.\\\hline
    \identifier{sp:g:primeprob}      & The acceptable error of primality tests is $2^{-\textrm{value}}$ (int).\\\hline
    \identifier{sp:g:statisticalzk}  & The acceptable statistical error in zero knowledge proofs is $2^{-\textrm{value}}$ (int).\\\hline
    \identifier{sp:g:challengesize}  & The size of the challenge in Fiat-Shamir proofs in bits.\\\hline
    \end{tabular}
    \caption{System parameters that must be generated by the global system parameter generator.}
    \label{tab:sysparam}
\end{table}


% ===========================================================================
% ===========================================================================
% ===========================================================================
    \subsubsection{Privacy-ABC Signatures}
    \identifier{b:sig}

    Signature schemes are the most essential building block for privacy ABCs.
    They can be used to obtain a signature on a set of (potentially hidden) attributes
    (potentially carried over from another signature),
    and one can then later prove possession of such a signature.

    The signature block has the following interfaces:
    the ones described in Sections \ref{sec:intf:all} and \ref{sec:intf:major},
    a system parameter generator (Section \ref{sec:intf:syspargen}),
    an issuer key pair generator (Section \ref{sec:intf:keygen}),
    a verifier parameter generator (Section \ref{sec:intf:verpargen}),
    three proof interfaces (Section \ref{sec:intf:proof}),
    and some extra interfaces for issuance.
    We now describe these interfaces in more detail.

    \paragraph{Key pair generator.}
    This block must generate at least the fields described in Table \ref{tab:issuerparamtemplate} for the key pair
    template.
    This block must generate at least the fields in the issuer public key described in Table \ref{tab:issuerparam},
    and at least the fields in the issuer private key described in Table \ref{tab:issuerparamsec}.

\begin{table}[p]
\centering
    \begin{tabular}{|l|p{0.5\textwidth}|}\hline
    \textbf{Field} & \textbf{Explanation} \\\hline
    \identifier{ic:g:pkuidprefix}  & A prefix for the unique URI to give to this public key.\\\hline
    \identifier{ic:g:technology}  & The URI of the implementation used by this key pair.\\\hline
    \identifier{ic:g:credspec}  & The URI of the credential specification that issuer key pair was generated for.\\\hline
    \identifier{ic:g:revauth}  & (Optional) The URI of the revocation authority used by this issuer.\\\hline
    \identifier{ic:g:desc:\emph{lang}}  & A human friendly description of the issuer (for language \emph{lang}).\\\hline
    \end{tabular}
    \caption{Elements that must be present in the issuer key pair template.}
    \label{tab:issuerparamtemplate}
\end{table}
\begin{table}[p]
\centering
    \begin{tabular}{|l|p{0.5\textwidth}|}\hline
    \textbf{Field} & \textbf{Explanation} \\\hline
    \identifier{ip:g:pkuid}  & The unique URI given to this public key.\\\hline
    \identifier{ip:g:spuid}  & The UID of the system parameters to use. \\\hline
    \identifier{ip:g:technology}  & The URI of the implementation used by this key pair.\\\hline
    \identifier{ip:g:credspec}  & The URI of the credential specification that issuer key pair was generated for.\\\hline
    \identifier{ip:g:revauth}  & (Optional) The URI of the revocation authority used by this issuer.\\\hline
    \identifier{ip:g:desc:\emph{lang}}  & A human friendly description of the issuer (for language \emph{lang}).\\\hline
    \identifier{ip:g:attcount}  & The number of addressable attributes in the credential specification.\\\hline
    \identifier{ip:g:externalatts}  & The number of external attributes (e.g., attributes on smartcards) in the
                                      credential specification (0 or 1).\\\hline
    \end{tabular}
    \caption{Elements that must be present in the issuer public key.}
    \label{tab:issuerparam}
\end{table}
\begin{table}[p]
\centering
    \begin{tabular}{|l|p{0.5\textwidth}|}\hline
    \textbf{Field} & \textbf{Explanation} \\\hline
    \identifier{is:g:pkuid}  & The URI of the corresponding public key.\\\hline
    \end{tabular}
    \caption{Elements that must be present in the issuer secret key.}
    \label{tab:issuerparamsec}
\end{table}

    \paragraph{Proof interface for presentation.}
    The proof interface for presentation of a signature is described here.
    The name of an addressable attribute in a given instance of this block
    consists of the identifier of the instance of the ZkModule concatenated
    with \texttt{:0}, \texttt{:1}, $\ldots$, \texttt{:$\emph{attcount-1}$};
    the name of the secret (if present) ends with \texttt{:secret}---other
    building blocks (such as the attribute equality block) can thus refer to these
    attributes.

      \begin{method}
      {ZkModuleProver}
      {getZkModuleProverPresentation}
      {
        {@in Map<Field, Value> systemParameters}
        {@in Map<Field, Value> verifierParameters}
        {@in Map<Field, Value> issuerPublicKey}
        {@in String identifierOfModule}
        {@in Signature signature}
        {@in List<BigInteger> encodedAttributes}
        {@in BigInteger credentialSpecId}
        {@in @Nullable URI identifierOfSecret}
        {@in @Nullable URI identifierOfSignatureForSecret}
        {@ref BuildingBlockFactory bbFactory \textrm{\emph{/* For creating new sub-blocks*/}}}
        {@ref ExternalSecretManager esManager \textrm{\emph{/* Manages e.g., smartcards*/}}}
      }
      This method creates a new ZkModuleProver object that will know how to perform
      a proof of possession of the signature.
      By default all attributes of the signature will be hidden---unless another
      building block (such as a RevealAttribute block) marks the
      attribute as revealed.

      The generated ZkModuleProver \emph{sets} the attribute values in the \emph{initialization} phase
      for all non-external attributes.
      \end{method}
      \begin{method}
      {ZkModuleVerifier}
      {getZkModuleVerifierPresentation}
      {
        {@in Map<Field, Value> systemParameters}
        {@in Map<Field, Value> verifierParameters}
        {@in Map<Field, Value> issuerPublicKey}
        {@in String identifierOfModule}
        {@in BigInteger credentialSpecId}
        {@ref BuildingBlockFactory bbFactory \textrm{\emph{/* For creating new sub-blocks*/}}}
      }
      This method creates a new ZkModuleVerifier object that will know how to verify
      a proof of possession of a signature.
      \end{method}
      % \begin{method}
      % {ZkModuleDescriber}
      % {getZkModuleDescriberPresentation}
      % {
        % {@in Map<Field, Value> systemParameters}
        % {@in Map<Field, Value> verifierParameters}
        % {@in Map<Field, Value> issuerPublicKey}
        % {@in String identifierOfModule}
        % {@in Signature signature}
        % {@in List<BigInteger> encodedAttributes}
        % {@in List<String> humanFriendlyAttributeValues}
        % {@in BigInteger credentialSpecId}
        % {@in @Nullable URI identifierOfSecret}
        % {@ref BuildingBlockFactory bbFactory \textrm{\emph{/* For creating new sub-blocks*/}}}
      % }
      % This method creates a new ZkModuleDescriber object that will know how to describe
      % what will be done in a proof of possession of the signature in the given credential.
      % \end{method}
    \paragraph{Proof interface for carry-over.}
    The prover interface for carrying over attributes for a new signature is described here.
    This block is intended to be used during the presentation phase of a complex issuance;
    at the issue of the presentation phase, the issuer can recover the committed attributes
    the user wishes to carry over to the new signature (these then serve as an input for
    the proof interface for issuance described later).

    Note that the proof engine will not do a range check of the carried-over attributes
    per default. In case an attribute is carried over from a credential that uses
    a known-order group to a credential that uses an unknown-order group or a group
    with a different known order, it is strongly recommended to manually add
    range proofs to the affected attributes to preserve security.

    The name of an addressable attribute in a given instance of this block
    will consist of the identifier of the instance of the ZkModule concatenated
    with \texttt{:0}, \texttt{:1}, $\ldots$, \texttt{:\emph{attcount-1}};
    the name of the secret (if present) will end with \texttt{:secret}---other
    building blocks (such as the attribute equality block) can thus refer to these
    attributes.

      \begin{method}
      {ZkModuleProver}
      {getZkModuleProverCarryOver}
      {
        {@in Map<Field, Value> systemParameters}
        {@in Map<Field, Value> verifierParameters}
        {@in Map<Field, Value> issuerPublicKey}
        {@in String identifierOfModule}
        {@in @Nullable URI identifierOfSecret \textrm{\emph{/* e.g., identifier of smartcard */}}}
        {@in @Nullable URI identifierOfSignatureForSecret}
        {@in BigInteger credentialSpecId}
        {@in List<Boolean> includeAttributeInCommitment}
        {@in List<@Nullable BigInteger> encodedAttributeValues}
        {@ref BuildingBlockFactory bbFactory \textrm{\emph{/* For creating new sub-blocks*/}}}
        {@ref ExternalSecretManager esManager \textrm{\emph{/* Manages e.g., smartcards*/}}}
      }
      This method creates a ZkModuleProver that will:
      (1) create a commitment for all the attributes where includeAttributeInCommitment is true, and
      the secret if identifierOfSecret is non null.
      (2) perform a proof of knowledge of the attribute values contained in these commitments;
      (3) transfer the commitments to the verifier.
      By default all attributes in the commitments will be hidden---unless another
      building block (such as a RevealAttribute block) marks the
      attribute as revealed.

      The generated ZkModuleProver \emph{sets} the attribute values in the \emph{initialization} phase
      for all attributes where encodedAttributeValues is not null.
      It \emph{requires} the attribute value for all attributes for which
      includeAttributeInCommitment is true and encodedAttributeValues is null.

      The ZkModuleProver that is created must implement the following additional methods:
        \begin{itemize}
          \item CarryOverStateRecipient recoverState()---returns an object that contains the commitment and the opening of the attributes
                that were generated, as well as a list of encoded attributes. The return value must be understood
                by the concrete instantiation of getZkModuleVerifierIssuance().
                This method may be called only after the proof is done.
        \end{itemize}
      \end{method}
      \begin{method}
      {ZkModuleVerifier}
      {getZkModuleVerifierCarryOver}
      {
        {@in Map<Field, Value> systemParameters}
        {@in Map<Field, Value> verifierParameters}
        {@in Map<Field, Value> issuerPublicKey}
        {@in String identifierOfModule}
        {@in BigInteger credentialSpecId}
        {@in List<Boolean> attributeSetByIssuer}
        {@ref BuildingBlockFactory bbFactory \textrm{\emph{/* For creating new sub-blocks*/}}}
      }
      This method creates a new ZkModuleVerifier object that will know how to:
      (1) recover the commitments made by the corresponding ZkModuleProver from the proof;
      (2) verify the proof of knowledge of the opening of these commitments.
      In the attributeSetByIssuer list, a value of ``false'' must be set if a non-null value
      was put in the same position in the encodedAttributeValues list in getZkModuleProverCarryOver,
      and a value of ``true'' if there was a null value.

      The ZkModuleVerifier that is created must implement the following additional methods:
        \begin{itemize}
          \item List<@Nullable BigInteger> recoverEncodedAttributes()---returns a list of all attributes
                that were revealed by the prover (null if unrevealed, or if the attribute has to be
                chosen by the issuer). This method may be called only after the proof verification has been
                completed.
          \item CarryOverStateIssuer recoverState()---returns an object that contains
                the commitments that were generated by the prover,
                as well as a list of all encoded attributes.
                This method may be called only after the proof verification has been completed. The
                return value must be understood by the concrete instantiation of getZkModuleProverIssuance().
        \end{itemize}
      \end{method}
      % \begin{method}
      % {ZkModuleDescriber}
      % {getZkModuleDescriberCarryOver}
      % {
        % {@in Map<Field, Value> systemParameters}
        % {@in Map<Field, Value> verifierParameters}
        % {@in Map<Field, Value> issuerPublicKey}
        % {@in String identifierOfModule}
        % {@in @Nullable URI identifierOfSecret \textrm{\emph{/* e.g., identifier of smartcard */}}}
        % {@in BigInteger credentialSpecId}
        % {@in List<Boolean> includeAttributeInCommitment}
        % {@in List<@Nullable BigInteger> encodedAttributeValues}
        % {@in List<@Nullable String> humanFriendlyAttributeValues}
        % {@ref BuildingBlockFactory bbFactory \textrm{\emph{/* For creating new sub-blocks*/}}}
      % }
      % This method creates a new ZkModuleDescriber object that will know how to describe
      % what the corresponding ZkModuleProver does.

      % The ZkModuleDescriber that is created must implement the following additional methods:
        % \begin{itemize}
          % \item List<@Nullable BigInteger> recoverEncodedAttributes().
                % This method may be called only after the description is done.
          % \item List<@Nullable String> recoverHumanFriendlyAttributes().
                % This method may be called only after the description is done.
        % \end{itemize}
      % \end{method}

    \paragraph{Interface for issuance.}
    The interfaces for issuing a new signature is described here; we start with the proof interface,
    and then handle the additional interfaces needed to accommodate signature schemes requiring multiple rounds.
    Issuance can either be \emph{from scratch}, meaning no presentation proof was done beforehand,
    otherwise they are \emph{complex}. For complex issuance with carried-over attributes, both the issuer and recipient need
    the carry-over state from the ZkModuleVerifier/ZkModuleProver that was used to prove knowledge of the carried-over attributes.
    The issuance of a new signature starts with a zero-knowledge proof through a standard proof interface,
    but, depending on the implementation, it may also require several additional rounds of communication after that.

    The name of an addressable attribute in a given instance of this block
    will consist of the identifier of the instance of the ZkModule concatenated
    with \texttt{:0}, \texttt{:1}, $\ldots$, \texttt{:\emph{attcount-1}}---other
    building blocks (such as the attribute equality block) can thus refer to these
    attributes.

      \begin{method}
      {ZkModuleProver}
      {getZkModuleProverIssuance}
      {
        {@in Map<Field, Value> systemParameters}
        {@in Map<Field, Value> verifierParameters}
        {@in Map<Field, Value> issuerPublicKey}
        {@in Map<Field, Value> issuerSecretKey}
        {@in String identifierOfModule}
        {@in BigInteger credentialSpecId}
        {@in List<@Nullable BigInteger> issuerSpecifiedAttributes}
        {@in @Nullable CarryOverStateIssuer carryOverState}
        {@ref BuildingBlockFactory bbFactory \textrm{\emph{/* For creating new sub-blocks*/}}}
      }
      This method is intended to be used by the issuer.
      This method creates a ZkModuleProver that:
      (1) does some preliminary work useful towards generating a signature (in some implementations, this method has enough information to
      generate the signature right now, others require additional steps) based on the attributes that were carried over and the issuer-specified attributes; and
      (2) knows how to perform a proof
      that step 1 was done honestly;
      and (3) is responsible for transferring some information to the recipient (in some implementations, the whole signature can be transmitted here,
      others require additional steps).

      The generated ZkModuleProver \emph{sets} the attribute values in the \emph{initialization} phase
      for all attributes where issuerSpecifiedAttributes is
      not null, and for all revealed attributes that were carried over.
      It \emph{requires} the attribute value for all attributes for which are not carried over, and which
      have a null entry in issuerSpecifiedAttributes.

      All issuer-specified attributes will be revealed.

      The ZkModuleProver that is created must implement the following additional methods:
        \begin{itemize}
          \item List<@Nullable BigInteger> recoverEncodedAttributes()---return a list of all attributes
          that were were set by the issuer, plus all attributes that were carried over and revealed.
                This method may be called only after the proof is done.
          \item IssuanceStateIssuer recoverIssuanceState()---returns arbitrary information that must be understood
                by extraIssuanceRoundIssuer(). This information contains (among others) the list of encoded attributes (as above).
                This method may be called only after the proof is done.
        \end{itemize}
      \end{method}
      \begin{method}
      {ZkModuleVerifier}
      {getZkModuleVerifierIssuance}
      {
        {@in Map<Field, Value> systemParameters}
        {@in Map<Field, Value> verifierParameters}
        {@in Map<Field, Value> issuerPublicKey}
        {@in String identifierOfModule}
        {@in @Nullable CarryOverStateRecipient carryOverState}
        {@in @Nullable URI identifierOfSecret \textrm{\emph{/* e.g., identifier of smartcard */}}}
        {@in @Nullable URI identifierSignatureForOfSecret}
        {@in BigInteger credentialSpecId}
        {@ref BuildingBlockFactory bbFactory \textrm{\emph{/* For creating new sub-blocks*/}}}
        {@ref ExternalSecretManager esManager \textrm{\emph{/* Manages e.g., smartcards*/}}}
      }
      This method is intended to be used by the recipient.
      This method creates a new ZkModuleVerifier object that will know how to:
      (1) recover the information send by the corresponding ZkModuleProver from the proof;
      (2) verify that this information was generated honestly.

      The ZkModuleVerifier that is created must implement the following additional methods:
        \begin{itemize}
          \item List<@Nullable BigInteger> recoverEncodedAttributes()---returns a list of all attributes
                in the signature. This method may only be called after the proof verification has been completed.
          \item IssuanceStateRecipient recoverIssuerInformation()---returns arbitrary information that must be
                understood by the concrete instantiation of extraIssuanceRoundRecipient() and recoverSignature().
                This information contains (among others) the list of encoded attributes.
                This method may be called only after the proof verification has been completed.
        \end{itemize}
      \end{method}
      % \begin{method}
      % {ZkModuleDescriber}
      % {getZkModuleDescriberIssuance}
      % {
        % {@in Map<Field, Value> systemParameters}
        % {@in Map<Field, Value> verifierParameters}
        % {@in Map<Field, Value> issuerPublicKey}
        % {@in String identifierOfModule}
        % {@in @Nullable CarryOverStateRecipient carryOverState}
        % {@in @Nullable URI identifierOfSecret \textrm{\emph{/* e.g., identifier of smartcard */}}}
        % {@in @Nullable URI identifierSignatureForSecret}
        % {@in BigInteger credentialSpecId}
        % {@ref BuildingBlockFactory bbFactory \textrm{\emph{/* For creating new sub-blocks*/}}}
      % }
      % This method is intended to be used by the recipient.
      % This method creates a new ZkModuleDescriber object that will know how to describe
      % what the corresponding ZkModuleVerifier does.
      % \end{method}
      \begin{getter}
      {int}
      {getNumberOfAdditionalIssuanceRoundtrips}
      This method returns the number of additional communication round-trips
      (one message from recipient to issuer and the response) needed for
      issuing the new signature.
      The recipient and the issuer need to call extraIssuanceRoundRecipient() and
      extraIssuanceRoundIssuer() respectively that many times, before the recipient may
      call recoverSignature().
      \end{getter}
      \begin{method}
      {IssuanceMessageToIssuer}
      {extraIssuanceRoundRecipient}
      {
        {@in @Nullable IssuanceMessageToRecipient messageFromIssuer}
        {@in Map<Field, Value> systemParameters}
        {@in Map<Field, Value> verifierParameters}
        {@in Map<Field, Value> issuerPublicKey}
        {@in String identifierOfModule}
        {@in @Nullable URI identifierOfSecret \textrm{\emph{/* e.g., identifier of smartcard */}}}
        {@in @Nullable URI identifierOfSignatureForSecret}
        {@in BigInteger credentialSpecId}
        {@in @Nullable CarryOverStateRecipient carryOverState}
        {@inout IssuanceStateRecipient stateRecipient}
        {@ref ExternalSecretManager esManager \textrm{\emph{/* Manages e.g., smartcards*/}}}
      }
      This method is intended to be used by the recipient.
      This method does some steps required to progress with the issuance of the signature,
      and outputs a message that is to be sent to the issuer.
      The method may update the issuance state.
      \end{method}
      \begin{method}
      {IssuanceMessageToRecipient}
      {extraIssuanceRoundIssuer}
      {
        {@in @Nullable IssuanceMessageToIssuer messageFromReceipient}
        {@in Map<Field, Value> systemParameters}
        {@in Map<Field, Value> verifierParameters}
        {@in Map<Field, Value> issuerPublicKey}
        {@in Map<Field, Value> issuerSecretKey}
        {@in String identifierOfModule}
        {@in BigInteger credentialSpecId}
        {@in List<@Nullable BigInteger> issuerSpecifiedAttributes}
        {@in @Nullable CarryOverStateIssuer carryOverState}
        {@inout IssuanceStateIssuer issuanceState}
      }
      This method is intended to be used by the issuer.
      This method does some steps required to progress with the issuance of the signature,
      and outputs a message that is to be sent to the recipient.
      The method may update the issuance state.
      \end{method}
      \begin{method}
      {List<Signature> + List<BigInteger>}
      {extractSignature}
      {
        {@in @Nullable IssuanceMessageToRecipient messageFromIssuer}
        {@in Map<Field, Value> systemParameters}
        {@in Map<Field, Value> verifierParameters}
        {@in Map<Field, Value> issuerPublicKey}
        {@in String identifierOfModule}
        {@in @Nullable URI identifierOfSecret \textrm{\emph{/* e.g., identifier of smartcard */}}}
        {@in @Nullable URI identifierSignatureForSecret}
        {@in BigInteger credentialSpecId}
        {@in IssuanceStateRecipient issuanceState}
        {@in @Nullable CarryOverStateRecipient carryOverState}
        {@ref ExternalSecretManager esManager \textrm{\emph{/* Manages e.g., smartcards*/}}}
      }
      This method is intended to be used by the recipient.
      This method extracts the signature from the state information.

      It returns the signature(s) that were generated (for CL: one signature,
      for Uprove: one signature per token), plus the list of encoded attributes
      that was signed.
      \end{method}

% ===========================================================================
% ===========================================================================
% ===========================================================================
    \subsubsection{Inspection}
    \identifier{b:ins}

    An inspection block allows one to verifiably encrypt/decrypt an attribute.
    The value of that attribute can then be recovered by
    a party called the inspector.

    The signature block has the following interfaces:
    the ones described in Sections \ref{sec:intf:all} and \ref{sec:intf:major},
    an inspector key pair generator (Section \ref{sec:intf:keygen}),
    a verifier parameter generator (Section \ref{sec:intf:verpargen}),
    and two proof interfaces (Section \ref{sec:intf:proof}) --- one for
    verifiable encryption and one for verifiable decryption---;
    and an interface for decryption.
    Note that there is no separate interface for just encryption: this is handled automatically by the proof interface.

    We now describe these interfaces in more detail.

    \paragraph{Key pair generator.}
    This block must generate at least the fields described in Table \ref{tab:inspar:templ} for the key pair
    template.
    This block must generate at least the fields in the issuer public key described in Table \ref{tab:inspar:pub},
    and at least the fields in the issuer private key described in Table \ref{tab:inspar:sec}.

\begin{table}[p]
\centering
    \begin{tabular}{|l|p{0.5\textwidth}|}\hline
    \textbf{Field} & \textbf{Explanation} \\\hline
    \identifier{ec:g:pkuidprefix}  & A prefix for the unique URI to give to this public key.\\\hline
    \identifier{ec:g:technology}  & The URI of the implementation used by this key pair.\\\hline
    \identifier{ec:g:desc:\emph{lang}}  & A human friendly description of the inspector (for language \emph{lang}).\\\hline
    \end{tabular}
    \caption{Elements that must be present in the inspector key pair template.}
    \label{tab:inspar:templ}
\end{table}
\begin{table}[p]
\centering
    \begin{tabular}{|l|p{0.5\textwidth}|}\hline
    \textbf{Field} & \textbf{Explanation} \\\hline
    \identifier{ep:g:pkuid}  & The unique URI given to this public key.\\\hline
    \identifier{ep:g:spuid}  & The UID of the system parameters to use. \\\hline
    \identifier{ep:g:technology}  & The URI of the implementation used by this key pair.\\\hline
    \identifier{ep:g:desc:\emph{lang}}  & A human friendly description of the inspector (for language \emph{lang}).\\\hline
    \end{tabular}
    \caption{Elements that must be present in the inspector public key.}
    \label{tab:inspar:pub}
\end{table}
\begin{table}[p]
\centering
    \begin{tabular}{|l|p{0.5\textwidth}|}\hline
    \textbf{Field} & \textbf{Explanation} \\\hline
    \identifier{es:g:pkuid}  & The URI of the corresponding public key.\\\hline
    \end{tabular}
    \caption{Elements that must be present in the inspector secret key.}
    \label{tab:inspar:sec}
\end{table}

    \paragraph{Proof interface for verifiable encryption.}
    The proof interface for the verifiable encryption of an attribute is described here.
      \begin{method}
      {ZkModuleProver}
      {getZkModuleProverEncryption}
      {
        {@in Map<Field, Value> systemParameters}
        {@in Map<Field, Value> verifierParameters}
        {@in Map<Field, Value> inspectorPublicKey}
        {@in String identifierOfModule}
        {@in String idOfAttributeToEncrypt}
        {@in String label}
        {@ref BuildingBlockFactory bbFactory \textrm{\emph{/* For creating new sub-blocks*/}}}
      }
      This method creates a new ZkModuleProver object that will
      encrypt the given attribute under the given label, and knows how to prove that this
      encryption was done correctly.

      This module \emph{requires} the value of idOfAttributeToEncrypt.

      The ZkModuleProver that is created must implement the following additional methods:
      \begin{itemize}
        \item byte[] getCiphertext()---returns the ciphertext of the verifiably encrypted attribute.
                This method may be called only after the proof is done.
      \end{itemize}

      \end{method}
      \begin{method}
      {ZkModuleVerifier}
      {getZkModuleVerifierEncryption}
      {
        {@in Map<Field, Value> systemParameters}
        {@in Map<Field, Value> verifierParameters}
        {@in Map<Field, Value> inspectorPublicKey}
        {@in String identifierOfModule}
        {@in String idOfAttributeToEncrypt}
        {@in byte[] ciphertext}
        {@in String label}
        {@ref BuildingBlockFactory bbFactory \textrm{\emph{/* For creating new sub-blocks*/}}}
      }
      This method creates a new ZkModuleVerifier object that will know how to verify
      that the given ciphertext is a correct encryption of the given attribute
      under the given label.
      \end{method}
      % \begin{method}
      % {ZkModuleDescriber}
      % {getZkModuleDescriberEncryption}
      % {
        % {@in Map<Field, Value> systemParameters}
        % {@in Map<Field, Value> verifierParameters}
        % {@in Map<Field, Value> inspectorPublicKey}
        % {@in String identifierOfModule}
        % {@in String idOfAttributeToEncrypt}
        % {@in String label}
        % {@ref BuildingBlockFactory bbFactory \textrm{\emph{/* For creating new sub-blocks*/}}}
      % }
      % This method creates a new ZkModuleDescriber object that will know how to describe
      % what the corresponding ZkModuleProver does.
      % \end{method}

    \paragraph{Proof interface for verifiable decryption.}
    The proof interface for the verifiable decryption of an attribute is described here.
      \begin{method}
      {ZkModuleProver}
      {getZkModuleProverDecryption}
      {
        {@in Map<Field, Value> systemParameters}
        {@in Map<Field, Value> verifierParameters}
        {@in Map<Field, Value> inspectorPublicKey}
        {@in Map<Field, Value> inspectorSecretKey}
        {@in String identifierOfModule}
        {@in byte[] ciphertext}
        {@in String label}
        {@ref BuildingBlockFactory bbFactory \textrm{\emph{/* For creating new sub-blocks*/}}}
      }
      This method is intended to be used by the inspector.
      This method creates a new ZkModuleProver object that will
      decrypt the given attribute under the given label, and knows how to prove that this
      decryption was done correctly.

      The ZkModuleProver that is created must implement the following additional methods:
      \begin{itemize}
        \item BigInteger getPlaintext()---returns the plaintext of the verifiably encrypted attribute.
                This method may be called only after the proof is done.
      \end{itemize}

      \end{method}
      \begin{method}
      {ZkModuleVerifier}
      {getZkModuleVerifierDecryption}
      {
        {@in Map<Field, Value> systemParameters}
        {@in Map<Field, Value> verifierParameters}
        {@in Map<Field, Value> inspectorPublicKey}
        {@in String identifierOfModule}
        {@in byte[] ciphertext}
        {@in String label}
        {@in BigInteger plaintext}
        {@ref BuildingBlockFactory bbFactory \textrm{\emph{/* For creating new sub-blocks*/}}}
      }
      This method creates a new ZkModuleVerifier object that will know how to verify
      that the given plaintext is a correct decryption of the corresponding ciphertext
      under the given label.
      \end{method}
      % \begin{method}
      % {ZkModuleDescriber}
      % {getZkModuleDescriberDecryption}
      % {
        % {@in Map<Field, Value> systemParameters}
        % {@in Map<Field, Value> verifierParameters}
        % {@in Map<Field, Value> inspectorPublicKey}
        % {@in Map<Field, Value> inspectorSecretKey}
        % {@in String identifierOfModule}
        % {@in byte[] ciphertext}
        % {@in String label}
        % {@ref BuildingBlockFactory bbFactory \textrm{\emph{/* For creating new sub-blocks*/}}}
      % }
      % This method is intended to be used by the inspector.
      % This method creates a new ZkModuleDescriber object that will know how to describe
      % what the corresponding ZkModuleProver does.
      % \end{method}

    \paragraph{Decryption.}
    The proof interface for decryption of an attribute is described here.
      \begin{method}
      {BigInteger}
      {decryptAttribute}
      {
        {@in Map<Field, Value> systemParameters}
        {@in Map<Field, Value> verifierParameters}
        {@in Map<Field, Value> inspectorPublicKey}
        {@in Map<Field, Value> inspectorSecretKey}
        {@in byte[] ciphertext}
        {@in String label}
      }
      This method is intended to be used by the inspector.
      This method decrypts the given ciphertext under the given label.
      \end{method}

% ===========================================================================
% ===========================================================================
% ===========================================================================
    \subsubsection{Revocation}
    \identifier{b:rev}

    Credentials may contain a special attribute that is marked as
    being a \emph{revocation handle}; with a revocation block
    a user can then prove that the revocation handle of his
    credential has not yet been revoked.

    The revocation block has the following interfaces:
    the ones described in Sections \ref{sec:intf:all} and \ref{sec:intf:major};
    a revocation authority key pair generator (Section \ref{sec:intf:keygen});
    a verifier parameter generator (Section \ref{sec:intf:verpargen});
    two proof interfaces (Section \ref{sec:intf:proof}) --- one for
    getting a fresh revocation handle and non-revocation evidence (via the revocation proxy),
    and one for proving non-revocation---;
    two interfaces to update the non-revocation evidence (via the revocation proxy or directly at the revocation authority);
    two interfaces to get the latest revocation information (via the revocation proxy or directly at the revocation authority);
    an interface to revoke a revocation handle;
    and an interface to generate a new revocation handle.

    We now describe these interfaces in more detail.
    \paragraph{Key pair generator.}
    This block must generate at least the fields described in Table \ref{tab:revpar:templ} for the key pair
    template.
    This block must generate at least the fields in the issuer public key described in Table \ref{tab:revpar:pub},
    and at least the fields in the issuer private key described in Table \ref{tab:revpar:sec}.

\begin{table}[p]
\centering
    \begin{tabular}{|l|p{0.5\textwidth}|}\hline
    \textbf{Field} & \textbf{Explanation} \\\hline
    \identifier{rc:g:pkuidprefix}  & A prefix for the unique URI to give to this public key.\\\hline
    \identifier{rc:g:technology}  & The URI of the implementation used by this key pair.\\\hline
    \identifier{rc:g:desc:\emph{lang}}  & A human friendly description of the revocation authority (for language \emph{lang}).\\\hline
    \end{tabular}
    \caption{Elements that must be present in the revocation authority key pair template.}
    \label{tab:revpar:templ}
\end{table}
\begin{table}[p]
\centering
    \begin{tabular}{|l|p{0.5\textwidth}|}\hline
    \textbf{Field} & \textbf{Explanation} \\\hline
    \identifier{rp:g:pkuid}  & The unique URI given to this public key.\\\hline
    \identifier{rp:g:spuid}  & The UID of the system parameters to use. \\\hline
    \identifier{rp:g:technology}  & The URI of the implementation used by this key pair.\\\hline
    \identifier{rp:g:desc:\emph{lang}}  & A human friendly description of the revocation authority (for language \emph{lang}).\\\hline
    \end{tabular}
    \caption{Elements that must be present in the revocation authority public key.}
    \label{tab:revpar:pub}
\end{table}
\begin{table}[p]
\centering
    \begin{tabular}{|l|p{0.5\textwidth}|}\hline
    \textbf{Field} & \textbf{Explanation} \\\hline
    \identifier{rs:g:pkuid}  & The URI of the corresponding public key.\\\hline
    \end{tabular}
    \caption{Elements that must be present in the revocation authority secret key.}
    \label{tab:revpar:sec}
\end{table}

    \paragraph{Proof interface for issuance.}
    This proof interface used during issuance of a revocable credential.

      \begin{method}
      {ZkModuleProver}
      {getZkModuleProverIssuance}
      {
        {@in Map<Field, Value> systemParameters}
        {@in Map<Field, Value> verifierParameters}
        {@in Map<Field, Value> raPublicKey}
        {@in String identifierOfModule}
        {@in String idOfRHAttribute}
        {@ref BuildingBlockFactory bbFactory \textrm{\emph{/* For creating new sub-blocks*/}}}
        {@ref RevocationProxy revocationProxy}
      }
      This method is intended to be called by the issuer.
      This method (1) queries the revocation authority via the revocation proxy
      to get a new revocation handle and the associated non-revocation evidence;
      (2) generates a ZkModuleProver that MAY be used to prove that the first
      operation was done honestly; and that MUST transfer the non-revocation evidence
      in the proof.

      This module \emph{sets} the attribute value of the revocation handle in the \emph{initialization phase}.
      \end{method}

      \begin{method}
      {ZkModuleVerifier}
      {getZkModuleVerifierIssuance}
      {
        {@in Map<Field, Value> systemParameters}
        {@in Map<Field, Value> verifierParameters}
        {@in Map<Field, Value> raPublicKey}
        {@in String identifierOfModule}
        {@in String idOfRHAttribute}
        {@ref BuildingBlockFactory bbFactory \textrm{\emph{/* For creating new sub-blocks*/}}}
      }
      This method is intended to be called by the recipient.
      This method creates a new ZkModuleVerifier object that recovers the
      non-revocation evidence from the proof and checks that the proof
      (if applicable) was done honestly.

      The ZkModuleVerifier that is created must implement the following additional methods:
      \begin{itemize}
        \item NonRevocationEvidence getNRE()---returns the non-revocation evidence from the proof. This method may
        be called only after the proof has been verified.
      \end{itemize}
      Note that the value of the revocation handle is transmitted though the ZkModule of the signature building block.
      \end{method}
      % \begin{method}
      % {ZkModuleDescriber}
      % {getZkModuleDescriberIssuance}
      % {
        % {@in Map<Field, Value> systemParameters}
        % {@in Map<Field, Value> verifierParameters}
        % {@in Map<Field, Value> raPublicKey}
        % {@in String identifierOfModule}
        % {@in String idOfRHAttribute}
        % {@ref BuildingBlockFactory bbFactory \textrm{\emph{/* For creating new sub-blocks*/}}}
      % }
      % This method is intended to be called by the recipient.
      % This method creates a new ZkModuleDescriber object that will know how to describe
      % what the corresponding ZkModuleVerifier does.
      % \end{method}
    \paragraph{Proof interface for proof of non-revocation.}
    This interface is used to prove that a given revocation handle has not been revoked.

      \begin{method}
      {ZkModuleProver}
      {getZkModuleProverPresentation}
      {
        {@in Map<Field, Value> systemParameters}
        {@in Map<Field, Value> verifierParameters}
        {@in Map<Field, Value> raPublicKey}
        {@in String identifierOfModule}
        {@in String identifierOfRHAttribute}
        {@in URI revocationInformationVersion}
        {@in NonRevocationEvidence nre}
        {@ref BuildingBlockFactory bbFactory \textrm{\emph{/* For creating new sub-blocks*/}}}
      }
      This method creates a new ZkModuleProver object that will know how to perform
      a proof that the given attribute (which is a revocation handle) has not
      been revoked.

      This module \emph{requires} the attribute value of the revocation handle. It may
      fail early if the attribute value is not consistent with the given non-revocation evidence.
      \end{method}
      \begin{method}
      {ZkModuleVerifier}
      {getZkModuleVerifierPresentation}
      {
        {@in Map<Field, Value> systemParameters}
        {@in Map<Field, Value> verifierParameters}
        {@in Map<Field, Value> raPublicKey}
        {@in String identifierOfModule}
        {@in String identifierOfRHAttribute}
        {@in URI revocationInformationVersion}
        {@in RevocationInformation revocationInfo}
        {@ref BuildingBlockFactory bbFactory \textrm{\emph{/* For creating new sub-blocks*/}}}
      }
      This method creates a new ZkModuleVerifier object that will know how to verify
      a proof that the given attribute (which is a revocation handle) has not
      been revoked.
      \end{method}
      % \begin{method}
      % {ZkModuleDescriber}
      % {getZkModuleDescriberPresentation}
      % {
        % {@in Map<Field, Value> systemParameters}
        % {@in Map<Field, Value> verifierParameters}
        % {@in Map<Field, Value> raPublicKey}
        % {@in String identifierOfModule}
        % {@in String identifierOfRHAttribute}
        % {@in URI revocationInformationVersion}
        % {@in NonRevocationEvidence nre}
        % {@ref BuildingBlockFactory bbFactory \textrm{\emph{/* For creating new sub-blocks*/}}}
      % }
      % This method creates a new ZkModuleProver object that will know how to describe
      % a proof that the given attribute (which is a revocation handle) has not
      % been revoked.
      % \end{method}


    \paragraph{Extra interfaces for users/verifiers.}
    We now show the interface for updating non-revocation evidence, and
    getting revocation information.
      \begin{method}
      {NonRevocationEvidence}
      {updateNonRevocationEvidenceViaProxy}
      {
        {@in Map<Field, Value> systemParameters}
        {@in Map<Field, Value> verifierParameters}
        {@in Map<Field, Value> raPublicKey}
        {@in @Nullable URI versionOfNRE \textrm{\textit{/*If null: latest version*/}}}
        {@in BigInteger revocationHandle}
        {@in @Nullable NonRevocationEvidence currentNonRevocationEvidence}
        {@ref RevocationProxy revocationProxy}
      }
      This method queries the revocation proxy to update the
      current non revocation evidence to a specific version
      (if versionOfNRE is null: to the latest version) in an unlinkable manner.
      This method MAY refuse to update to an earlier version of the NRE.
      If currentNonRevocationEvidence is null, then the method MAY also
      provide the specific version of the revocation evidence, but in a
      linkable manner.
      \end{method}
      \begin{method}
      {RevocationInformation}
      {updateRevocationInformationViaProxy}
      {
        {@in Map<Field, Value> systemParameters}
        {@in Map<Field, Value> verifierParameters}
        {@in Map<Field, Value> raPublicKey}
        {@in @Nullable URI versionOfRE \textrm{\textit{/*If null: latest version*/}}}
        {@in @Nullable RevocationInformation currentRevocationInformation}
        {@ref RevocationProxy revocationProxy}
      }
      This method queries the revocation proxy to get
      a specific version of the revocation information
      (if versionOfRE is null: the latest version).
      \end{method}
    \paragraph{Extra interfaces for revocation authority.}
      \begin{method}
      {NreUpdateResponse}
      {updateNonRevocationEvidence}
      {
        {@in Map<Field, Value> systemParameters}
        {@in Map<Field, Value> verifierParameters}
        {@in Map<Field, Value> raPublicKey}
        {@in Map<Field, Value> raSecretKey}
        {@in @Nullable URI previousVersionOfNRE \textrm{\textit{/*If null: don't update; generate new NRE*/}}}
        {@in @Nullable URI versionOfNRE \textrm{\textit{/*If null: latest version*/}}}
        {@in NreUpdateRequest request}
        {@ref RevocationAuthorityState state}
      }
      This method is intended to be called by the revocation authority, after it
      was called though the revocation proxy.
      This method helps the caller update a non revocation evidence to a specific version
      (if versionOfNRE is null: to the latest version) in an unlinkable manner.
      This method MAY refuse to update to an earlier version of the NRE.
      If previousVersionOfNRE is null, then the method MAY also
      provide the specific version of the revocation evidence, but in a
      linkable manner.
      The contents of the request and the response in the return value are understood by the specific implementation of the revocation building block
      (functions updateNonRevocationEvidenceViaProxy and the current one).
      \end{method}
      \begin{method}
      {RevocationInformation}
      {updateRevocationInformation}
      {
        {@in Map<Field, Value> systemParameters}
        {@in Map<Field, Value> verifierParameters}
        {@in Map<Field, Value> raPublicKey}
        {@in Map<Field, Value> raSecretKey}
        {@in @Nullable URI versionOfRE \textrm{\textit{/*If null: latest version*/}}}
        {@in @Nullable RevocationInformation currentRevocationInformation}
        {@ref RevocationAuthorityState state}
      }
      This method is intended to be called by the revocation authority, after it was called
      though the revocation proxy.
      This method returns
      a specific version of the revocation information
      (if versionOfRE is null: the latest version).
      \end{method}
      \begin{method}
      {URI}
      {revoke}
      {
        {@in Map<Field, Value> systemParameters}
        {@in Map<Field, Value> verifierParameters}
        {@in Map<Field, Value> raPublicKey}
        {@in Map<Field, Value> raSecretKey}
        {@in BigInteger revocationHandle}
        {@ref RevocationAuthorityState state}
      }
      This method is intended to be called by the revocation authority.
      This method revokes the specified revocationHandle, and updates
      the state accordingly.
      This method returns the current version of the revocation information.
      \end{method}
      \begin{method}
      {NonRevocationEvidence + BigInteger + URI}
      {newRevocationHandle}
      {
        {@in Map<Field, Value> systemParameters}
        {@in Map<Field, Value> verifierParameters}
        {@in Map<Field, Value> raPublicKey}
        {@in Map<Field, Value> raSecretKey}
        {@ref RevocationAuthorityState state}
      }
      This method is intended to be called by the revocation authority, after it
      was called through the revocation proxy.
      This method generates a revocation handle, and the corresponding non revocation
      evidence; and updates
      the state accordingly.
      This method returns the generated non revocation evidence, the new revocation handle,
      and the current version of the revocation information.
      \end{method}



% ===========================================================================
% ===========================================================================
% ===========================================================================
    \subsubsection{Pseudonyms}
    \identifier{b:nym}

    This block is used for both scope-exclusive and non-scope-exclusive pseudonyms.

    The pseudonym block has the following interfaces:
    the ones described in Sections \ref{sec:intf:all} and \ref{sec:intf:major};
    a verifier parameter generator (Section \ref{sec:intf:verpargen});
    a proof interface (Section \ref{sec:intf:proof}) for presenting a pseudonym;
    and an interface to create a new pseudonym.
      We now describe these interfaces in more detail.


    \paragraph{Proof interface for presentation.}
    This proof interface used during presentation of a pseudonym.
    The name of the attribute holding the secret consists of the identifier
    of the instance of the ZkModule concatenated with \texttt{:secret}---other
    building blocks (such as the attribute equality block) can thus refer to this
    attribute.
      \begin{method}
      {ZkModuleProver}
      {getZkModuleProver}
      {
        {@in Map<Field, Value> systemParameters}
        {@in Map<Field, Value> verifierParameters}
        {@in String identifierOfModule}
        {@in Pseudonym pseudonym}
        {@ref BuildingBlockFactory bbFactory \textrm{\emph{/* For creating new sub-blocks*/}}}
        {@ref ExternalSecretManager esManager \textrm{\emph{/* Manages e.g., smartcards*/}}}
      }
      This method creates a new ZkModuleProver object that will know how to
      perform a proof of possession of the secret in the given pseudonym.

      The ZkModuleProver that is created must implement the following additional methods:
      \begin{itemize}
        \item byte[] getPseudonymValue()---returns the value of the pseudonym.
      \end{itemize}
      \end{method}
      \begin{method}
      {ZkModuleVerifier}
      {getZkModuleVerifier}
      {
        {@in Map<Field, Value> systemParameters}
        {@in Map<Field, Value> verifierParameters}
        {@in String identifierOfModule}
        {@in URI scopeOfPseudonym}
        {@in byte[] valueOfPseudonym}
        {@ref BuildingBlockFactory bbFactory \textrm{\emph{/* For creating new sub-blocks*/}}}
      }
      This method creates a new ZkModuleVerifier object that will know how to
      verify a proof of possession of the secret in the given pseudonym.
      \end{method}
      %%%\begin{method}
      %{ZkModuleDescriber}
      %{getZkModuleDescriber}
      %{
        %{@in Map<Field, Value> systemParameters}
        %{@in Map<Field, Value> verifierParameters}
        %{@in String identifierOfModule}
        %{@in Pseudonym pseudonym}
        %{@ref BuildingBlockFactory bbFactory \textrm{\emph{/* For creating new sub-blocks*/}}}
        %{@ref ExternalSecretManager esManager \textrm{\emph{/* Manages e.g., smartcards*/}}}
      %}
      %This method creates a new ZkModuleProver object that will know how to
      %describe a proof of possession of the secret in the given pseudonym.
      %\end{method}
      \paragraph{Create a new Pseudonym.}
      \begin{method}
      {Pseudonym}
      {createPseudonym}
      {
        {@in Map<Field, Value> systemParameters}
        {@in Map<Field, Value> verifierParameters}
        {@in URI secretLocation \textrm{\emph{/* e.g., smartcard URI*/}}}
        {@in URI scope}
        {@ref ExternalSecretManager esManager \textrm{\emph{/* Manages e.g., smartcards*/}}}
      }
      This method creates a new pseudonym with the given scope and with the given secret.
      \end{method}

% ===========================================================================
% ===========================================================================
% ===========================================================================
    \subsubsection{Not-Equal Proofs}
    \identifier{b:ne}
    \notimplemented
    
    A not-equal building block is used to prove that a given attribute (or constant)
    is not equal to a given attribute (or constant).

    The not-equal block has the following interfaces:
    the ones described in Sections \ref{sec:intf:all} and \ref{sec:intf:major};
    a verifier parameter generator (Section \ref{sec:intf:verpargen});
    and a proof interface (Section \ref{sec:intf:proof}).
      We now describe these interfaces in more detail.

    \paragraph{Proof interface.}
      \begin{method}
      {ZkModuleProver}
      {getZkModuleProver}
      {
        {@in Map<Field, Value> systemParameters}
        {@in Map<Field, Value> verifierParameters}
        {@in String identifierOfModule}
        {@in String idOfLhsAttribute}
        {@in String idOfRhsAttribute}
        {@ref BuildingBlockFactory bbFactory \textrm{\emph{/* For creating new sub-blocks*/}}}
      }
      This method creates a new ZkModuleProver object that will know how to
      perform a proof that the left-hand-side operand is not equal to the
      right-hand-side operand.

      This module \emph{requires} the attribute value of the two operands.
      If an operand is a constant, then a ``Constant Attribute'' block must be added.

      \end{method}
      \begin{method}
      {ZkModuleVerifier}
      {getZkModuleVerifier}
      {
        {@in Map<Field, Value> systemParameters}
        {@in Map<Field, Value> verifierParameters}
        {@in String identifierOfModule}
        {@in String idOfLhsAttribute}
        {@in String idOfRhsAttribute}
        {@ref BuildingBlockFactory bbFactory \textrm{\emph{/* For creating new sub-blocks*/}}}
      }
      This method creates a new ZkModuleVerifier object that will know how to
      verify a proof that the left-hand-side operand is not equal to the
      right-hand-side operand.
      \end{method}
      %\begin{method}
      %{ZkModuleDescriber}
      %{getZkModuleDescriber}
      %{
        %{@in Map<Field, Value> systemParameters}
        %{@in Map<Field, Value> verifierParameters}
        %{@in String identifierOfModule}
        %{@in String idOfLhsAttribute}
        %{@in String idOfRhsAttribute}
        %{@ref BuildingBlockFactory bbFactory \textrm{\emph{/* For creating new sub-blocks*/}}}
      %%}
      %This method creates a new ZkModuleDescriber object that will know how to
      %describe a proof that the left-hand-side operand is not equal to the
      %right-hand-side operand.
      %\end{method}

% ===========================================================================
% ===========================================================================
% ===========================================================================
    \subsubsection{Inequality Proof}
    \identifier{b:ineq}

    An inequality building block is used to prove that a given attribute (or constant)
    is smaller/smaller-or-equal/larger/larger-or-equal than a given attribute (or constant).

    The inequality block has the following interfaces:
    the ones described in Sections \ref{sec:intf:all} and \ref{sec:intf:major};
    a verifier parameter generator (Section \ref{sec:intf:verpargen});
    and a proof interface (Section \ref{sec:intf:proof}).
      We now describe these interfaces in more detail.

    \paragraph{Proof interface.}
      \begin{method}
      {ZkModuleProver}
      {getZkModuleProver}
      {
        {@in Map<Field, Value> systemParameters}
        {@in Map<Field, Value> verifierParameters}
        {@in String identifierOfModule}
        {@in String idOfLhsAttribute}
        {@in String idOfRhsAttribute}
        {@in Operator operator \textrm{\emph{/* Enum of: \texttt{LT}, \texttt{LE}, \texttt{GT}, \texttt{GE} */}}}
        {@ref BuildingBlockFactory bbFactory \textrm{\emph{/* For creating new sub-blocks*/}}}
      }
      This method creates a new ZkModuleProver object that will know how to
      perform a proof that the left-hand-side operand is less-than/less-or-equal/greater-than/greater-or-equal than the
      right-hand-side operand.

      This module \emph{requires} the attribute value of the two operands.

      If an operand is a constant, then a ``Constant Attribute'' block must be added.
      \end{method}
      \begin{method}
      {ZkModuleVerifier}
      {getZkModuleVerifier}
      {
        {@in Map<Field, Value> systemParameters}
        {@in Map<Field, Value> verifierParameters}
        {@in String identifierOfModule}
        {@in String idOfLhsAttribute}
        {@in String idOfRhsAttribute}
        {@in Operator operator \textrm{\emph{/* Enum of: \texttt{LT}, \texttt{LE}, \texttt{GT}, \texttt{GE} */}}}
        {@ref BuildingBlockFactory bbFactory \textrm{\emph{/* For creating new sub-blocks*/}}}
      }
      This method creates a new ZkModuleVerifier object that will know how to
      verify a proof that the left-hand-side operand is less-than/less-or-equal/greater-than/greater-or-equal than the
      right-hand-side operand.
      \end{method}
      % \begin{method}
      % {ZkModuleDescriber}
      % {getZkModuleDescriber}
      % {
        % {@in Map<Field, Value> systemParameters}
        % {@in Map<Field, Value> verifierParameters}
        % {@in String identifierOfModule}
        % {@in String idOfLhsAttribute}
        % {@in String idOfRhsAttribute}
        % {@in Operator operator \textrm{\emph{/* Enum of: \texttt{LT}, \texttt{LE}, \texttt{GT}, \texttt{GE} */}}}
        % {@ref BuildingBlockFactory bbFactory \textrm{\emph{/* For creating new sub-blocks*/}}}
      % }
      % This method creates a new ZkModuleDescriber object that will know how to
      % describe a proof that the left-hand-side operand is less-than/less-or-equal/greater-than/greater-or-equal than the
      % right-hand-side operand.
      % \end{method}

% ===========================================================================
% ===========================================================================
% ===========================================================================
    \subsubsection{Set Membership Proof}
    \identifier{b:setmem} \notimplemented

    A set membership building block is used to prove that the value of a given attribute
    is contained in a given set.

    The inequality block has the following interfaces:
    the ones described in Sections \ref{sec:intf:all} and \ref{sec:intf:major};
    a verifier parameter generator (Section \ref{sec:intf:verpargen});
    and a proof interface (Section \ref{sec:intf:proof}).
      We now describe these interfaces in more detail.

    \paragraph{Proof interface.}
      \begin{method}
      {ZkModuleProver}
      {getZkModuleProver}
      {
        {@in Map<Field, Value> systemParameters}
        {@in Map<Field, Value> verifierParameters}
        {@in String identifierOfModule}
        {@in String identifierOfAttribute \textrm{\emph{/* operand */}}}
        {@in List<BigInteger> allowedValues}
        {@ref BuildingBlockFactory bbFactory \textrm{\emph{/* For creating new sub-blocks*/}}}
      }
      This method creates a new ZkModuleProver object that will know how to
      perform a proof that the given operand is equal to one of the allowed values.

      This module \emph{requires} the attribute value of the operands.
      \end{method}
      \begin{method}
      {ZkModuleVerifier}
      {getZkModuleVerifier}
      {
        {@in Map<Field, Value> systemParameters}
        {@in Map<Field, Value> verifierParameters}
        {@in String identifierOfModule}
        {@in String identifierOfAttribute \textrm{\emph{/* operand */}}}
        {@in List<BigInteger> allowedValues}
        {@ref BuildingBlockFactory bbFactory \textrm{\emph{/* For creating new sub-blocks*/}}}
      }
      This method creates a new ZkModuleVerifier object that will know how to
      verify a proof that the given operand is equal to one of the allowed values.
      \end{method}
      % \begin{method}
      % {ZkModuleDescriber}
      % {getZkModuleDescriber}
      % {
        % {@in Map<Field, Value> systemParameters}
        % {@in Map<Field, Value> verifierParameters}
        % {@in String identifierOfModule}
        % {@in String identifierOfAttribute \textrm{\emph{/* operand */}}}
        % {@in List<BigInteger> allowedValues}
        % {@in List<String> HumanFriendlyAllowedValues}
        % {@ref BuildingBlockFactory bbFactory \textrm{\emph{/* For creating new sub-blocks*/}}}
      % }
      % This method creates a new ZkModuleDescriber object that will know how to
      % describe a proof that the given operand is equal to one of the allowed values.
      % \end{method}

% ===========================================================================
% ===========================================================================
% ===========================================================================
    \subsubsection{Jointly-Random Attributes}
    \identifier{b:jrand} \notimplemented

    A Joint-Random block is used during issuance of a signature, so
    that the recipient and issuer can jointly generate a random attribute value.
    (By default this value will not be revealed to the issuer.)

    The inequality block has the following interfaces:
    the ones described in Sections \ref{sec:intf:all} and \ref{sec:intf:major};
    a verifier parameter generator (Section \ref{sec:intf:verpargen});
    a few interfaces for preliminary communication between the recipient and issuer;
    and a proof interface (Section \ref{sec:intf:proof}).
      We now describe these interfaces in more detail.

    \paragraph{Preliminary communication.}
      \begin{getter}
      {int}
      {getNumberOfPreliminaryRoundtrips}
      This method returns the number of additional preliminary communication round-trips
      (one message from recipient to issuer plus the response) needed for
      agreeing on a jointly random attribute.
      The recipient and the issuer need to call preliminaryRoundRecipient() and
      preliminaryRoundIssuer() respectively that many times, before the recipient may
      call getZkModuleProver() and the verifier may call getZkModuleVerifier().
      \end{getter}
      \begin{getter}
      {JointRandomStateRecipient}
      {newJointRandomStateRecipient}
      \end{getter}
      \begin{getter}
      {JointRandomStateIssuer}
      {newJointRandomStateIssuer}
      \end{getter}
      \begin{method}
      {JointRandomMessageToIssuer}
      {preliminaryRoundRecipient}
      {
        {@in @Nullable JointRandomMessageToRecipient messageFromIssuer}
        {@ref JointRandomStateRecipient state}
        {@in Map<Field, Value> systemParameters}
        {@in Map<Field, Value> verifierParameters}
        {@in String identifierOfModule}
        {@ref BuildingBlockFactory bbFactory \textrm{\emph{/* For creating new sub-blocks*/}}}
      }
      This method is intended to be used by the recipient.
      This method does some steps required to progress with the determination of
      a random attribute value,
      and outputs a message that is to be sent to the issuer.
      For the first call to this function, the user provides a NULL-valued messageFromIssuer.
      \end{method}
      \begin{method}
      {JointRandomMessageToRecipient}
      {preliminaryRoundIssuer}
      {
        {@in JointRandomMessageToIssuer messageFromReceipient}
        {@ref JointRandomStateIssuer state}
        {@in Map<Field, Value> systemParameters}
        {@in Map<Field, Value> verifierParameters}
        {@in String identifierOfModule}
        {@ref BuildingBlockFactory bbFactory \textrm{\emph{/* For creating new sub-blocks*/}}}
      }
      This method is intended to be used by the issuer.
      This method does some steps required to progress with the determination of
      a random attribute value,
      and outputs a message that is to be sent to the recipient.
      \end{method}

      \paragraph{Proof interface.}
      \begin{method}
      {ZkModuleProver}
      {getZkModuleProver}
      {
        {@in @Nullable JointRandomMessageToRecipient lastMessageFromIssuer}
        {@ref JointRandomStateRecipient state}
        {@in Map<Field, Value> systemParameters}
        {@in Map<Field, Value> verifierParameters}
        {@in String identifierOfModule}
        {@in String identifierOfAttribute}
        {@ref BuildingBlockFactory bbFactory \textrm{\emph{/* For creating new sub-blocks*/}}}
      }
      This method is intended to be used by the recipient.
      This method creates a new ZkModuleProver object that will know how to
      perform a proof that the given attribute was generated jointly at random
      between the recipient and the issuer.

      This module \emph{sets} the attribute value in the \emph{initialization} phase.
      \end{method}
      \begin{method}
      {ZkModuleVerifier}
      {getZkModuleVerifier}
      {
        {@ref JointRandomStateIssuer state}
        {@in Map<Field, Value> systemParameters}
        {@in Map<Field, Value> verifierParameters}
        {@in String identifierOfModule}
        {@in String identifierOfAttribute}
        {@ref BuildingBlockFactory bbFactory \textrm{\emph{/* For creating new sub-blocks*/}}}
      }
      This method is intended to be used by the issuer.
      This method creates a new ZkModuleVerifier object that will know how to
      verify a proof that the given attribute was generated jointly at random
      between the recipient and the issuer.
      \end{method}
      % \begin{method}
      % {ZkModuleDescriber}
      % {getZkModuleDescriber}
      % {
        % {@in Map<Field, Value> systemParameters}
        % {@in Map<Field, Value> verifierParameters}
        % {@in String identifierOfModule}
        % {@in String identifierOfAttribute}
        % {@ref BuildingBlockFactory bbFactory \textrm{\emph{/* For creating new sub-blocks*/}}}
      % }
      % This method is intended to be used by the recipient.
      % This method creates a new ZkModuleDescriber object that will know how to
      % describe a proof that that the given attribute was generated jointly at random
      % between the recipient and the issuer.
      % \end{method}

