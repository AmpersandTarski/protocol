%!TEX root =  IdmxSpecification.tex

\section{Detailed Design of Major Components of Crypto Engine}
  \subsection{Building Block Factory}
    The Building Block Factory is used to get instances of building blocks.
    The client can either specify that he wants a specific implementation, or that he wants
    an implementation that is compatible with the verifier parameters.

    The Building Block Factory is implementation-agnostic.

    The Building Block Factory is also involved during parameter/key generation, when it is needed
    to iterate over all known building block implementations.

  \subsection{State Storage (issuance)}
  The State Storage is used by the recipient and the issuer during the issuance protocol to store
  intermediate state during the issuance protocol.
  Intermediate state is indexed by issuance context.
  Intermediate state may be retrieved only once (it is then deleted); the recipient/issuer will
  store an updated state if necessary.
  The State Storage also remembers the list of all issuance contexts it has ever seen.
  No other part of the crypto engine may store state.

  This way, the thread safety of the crypto engine is simplified.

  \subsection{Proof Assembler (prover)}
    The Proof Assembler receives as input an (incomplete) Presentation Token Description
    and a list of credential and pseudonym URIs.

    The role of the Proof Assembler (prover) is to generate a list of ZkModuleProver
    that is used as input for the Proof Engine, to generate a Mechanism Specification
    indicating the choice of implementation that was made, and to update the Presentation
    Token Description received from the upper layers.
    The list of ZkModules is passed to the Proof Engine, which outputs a Zero-Knowledge
    Proof. The updated Presentation Token Description, the Mechanism Specification, and
    the Zero-Knowledge Proof form the Presentation Token.

    The Proof Assembler queries the Credential Manager for Credentials and
    Pseudonyms, and queries the Key Manager for parameters and public keys.
    It uses the Building Block Factory to generate the required Building Blocks. These
    Building Blocks are used to generate ZkModuleProvers; the Proof Assembler
    injects the Smartcard Manager into these ZkModuleProvers if necessary.

    The Proof Assembler is implementation agnostic.

    Concretely, the proof assembler does the following:
    \begin{enumerate}
      \item Initialize the ZkModuleFactory with the verifier parameters.
      \item Create a new Mechanism Specification. Set the system parameters UID and the proof system UID fields.
      \item Go though the list of credentials and pseudonyms to learn their aliases.
      \item Process the list of messages in the presentation token description:
        \begin{enumerate}
          \item Retrieve a Message Building Block from the ZkModuleFactory.
          \item Create a ZkModuleProver using the Building Block. Set the name of the ZkModule to
            \texttt{msg:n} if this is the $(n+1)$st message in the list.
        \end{enumerate}
      \item Process the list of pseudonyms in the presentation token description:
        \begin{enumerate}
          \item Fetch the pseudonym from the Credential Manager (new pseudonyms have already been created at this point by the upper layers).
          \item Retrieve a Pseudonym Building Block with the same implementation as the pseudonym from the ZkModuleFactory.
          \item Create a ZkModuleProver using the Building Block. Set the name of the ZkModule to
            \texttt{nym:n} if this is the $(n+1)$st pseudonym in the list.
          \item Update the mechanism specification with the identifier of the implementation being used.
          \item If there is a same key binding as clause:
            \begin{enumerate}
              \item Retrieve an AttributeEquality Block from the ZkModuleFactory.
              \item Create a ZkModuleProver using the Building Block. Set the name of the ZkModule to
                \texttt{eq:secret:nym:n} if this is the $(n+1)$st pseudonym in the list.
            \end{enumerate}
        \end{enumerate}
      \item Process the list of credentials in the presentation token description:
        \begin{enumerate}
          \item Fetch the credential from the Credential Manager. Extract the signature, list of encoded attributes, and binding information to external secrets.
          \item Fetch the credential specification from the Key Manager.
          \item Fetch the issuer's public key from the Key Manager.
          \item Retrieve a Credential Specification Building Block from the ZkModuleFactory. Determine the unique identifier
            of the credential specification. Create a ZkModuleProver using this Building Block. Set the name of the ZkModule to
            \texttt{sig:n:cs} if this is the $(n+1)$st credential in the list.
          \item Retrieve a Issuer Public Key Building Block from the ZkModuleFactory.
            Create a ZkModuleProver using this Building Block and load it with the key. Set the name of the ZkModule to
            \texttt{sig:n:ip} if this is the $(n+1)$st credential in the list.
          \item Retrieve a Privacy-ABC Signature Building Block with the same implementation as the credential from the ZkModuleFactory.
          \item Create a ZkModuleProver for presentation using the Building Block. Set the name of the ZkModule to
            \texttt{sig:n} if this is the $(n+1)$st credential in the list.
          \item If the credential is revocable:
            \begin{enumerate}
              \item Extract the non-revocation evidence from the credential.
              \item Fetch the public key of the revocation authority from the Key Manager.
              \item Retrieve a Revocation Building Block with the same implementation as used by the revocation authority from the ZkModuleFactory.
              \item Create a ZkModuleProver for presentation using the Building Block. Set the name of the ZkModule to
                \texttt{sig:n:rev} if this is the $(n+1)$st credential in the list.
              \item Retrieve a Revocation Authority Public Key Building Block from the ZkModuleFactory.
                Create a ZkModuleProver using this Building Block and load it with the key. Set the name of the ZkModule to
                \texttt{sig:n:rev:key:inspectorKey} if this is the $(n+1)$st credential in the list.
            \end{enumerate}
          \item For all revealed attributes in the credential:
            \begin{enumerate}
              \item Retrieve a Reveal Attribute Block from the ZkModuleFactory.
              \item Create a ZkModuleProver using the Building Block. Set the name of the ZkModule to
                \texttt{reveal:n:m} if this is the $(m+1)$st DisclosedAttribute element of the $(n+1)$st credential in the list.
            \end{enumerate}
          \item For all inspectable attributes in the credential:
            \begin{enumerate}
              \item Retrieve the inspector's public key from the Key Manager.
              \item Retrieve an Inspection Block using the same implementation as the inspector's key from the ZkModuleFactory.
              \item Create a ZkModuleProver for encryption using the Building Block. Set the name of the ZkModule to
                \texttt{sig:n:ins:m} if this is the $(m+1)$st DisclosedAttribute element of the $(n+1)$st credential in the list.
              \item Retrieve a Inspector Public Key Building Block from the ZkModuleFactory.
                Create a ZkModuleProver using this Building Block and load it with the key. Set the name of the ZkModule to
                \texttt{sig:n:ins:m:inspectorKey} if this is the $(m+1)$st DisclosedAttribute element of the $(n+1)$st credential in the list.
            \end{enumerate}
          \item If there is a same key binding as clause:
            \begin{enumerate}
              \item Retrieve an AttributeEquality Block from the ZkModuleFactory.
              \item Create a ZkModuleProver using the Building Block. Set the name of the ZkModule to
                \texttt{eq:secret:sig:n} if this is the $(n+1)$st credential in the list.
            \end{enumerate}
        \end{enumerate}
      \item Process the list of predicates in the proof:
        \begin{enumerate}
          \item For each constant argument:
            \begin{enumerate}
              \item Retrieve a Constant Attribute Building Block from the ZkModuleFactory.
              \item Create a ZkModuleProver using the Building Block. Set the name of the ZkModule to
                \texttt{constant:n:m} if this is the $(m+1)$st argument of the $(n+1)$st predicate.
            \end{enumerate}
          \item If the function calls for a not-equal proof: \notimplemented
            \begin{enumerate}
              \item Retrieve a Not-Equal Proof Building Block from the ZkModuleFactory (any implementation that is understood by the verifier).
              \item Create a ZkModuleProver using the Building Block. Set the name of the ZkModule to
                \texttt{ne:n} if this is the $(n+1)$st predicate.
              \item Update the mechanism specification with the identifier of the implementation being used.
            \end{enumerate}
          \item If the function calls for an inequality proof:
            \begin{enumerate}
              \item Retrieve an Inequality Proof Building Block from the ZkModuleFactory (any implementation that is understood by the verifier).
              \item Create a ZkModuleProver using the Building Block. Set the name of the ZkModule to
                \texttt{ineq:n} if this is the $(n+1)$st predicate.
              \item Update the mechanism specification with the identifier of the implementation being used.
            \end{enumerate}
          \item If the function calls for an equality proof:
            \begin{enumerate}
              \item Retrieve an Attribute Equality Building Block from the ZkModuleFactory.
              \item Create a ZkModuleProver using the Building Block. Set the name of the ZkModule to
                \texttt{eq:n} if this is the $(n+1)$st predicate.
            \end{enumerate}
          \item If the function calls for a one-of proof (for a datatype that uses prime encoding): \notimplemented
            \begin{enumerate}
              \item Retrieve a Set Membership Building Block from the ZkModuleFactory (any implementation that is understood by the verifier).
              \item Create a ZkModuleProver using the Building Block. Set the name of the ZkModule to
                \texttt{setmem:n} if this is the $(n+1)$st predicate.
              \item Update the mechanism specification with the identifier of the implementation being used.
            \end{enumerate}
        \end{enumerate}
      \item Add the system parameters:
        \begin{enumerate}
          \item Retrieve the System Parameters from the KeyManager.
          \item Retrieve a Parameters Building Block from the ZkModuleFactory.
          \item Create a ZkModuleProver using the Building Block. Set the name of the ZkModule to
            \texttt{param:sp}.
        \end{enumerate}
      \item Add the verifier parameters:
        \begin{enumerate}
          \item Retrieve a Parameters Building Block from the ZkModuleFactory.
          \item Create a ZkModuleProver using the Building Block. Set the name of the ZkModule to
            \texttt{param:vp}.
        \end{enumerate}
      \item Add the mechanism specification:
        \begin{enumerate}
          \item Retrieve a Mechanism Specification Building Block from the ZkModuleFactory.
          \item Create a ZkModuleProver using the Building Block. Set the name of the ZkModule to
            \texttt{param:ms}.
        \end{enumerate}
      \item Add the presentation token description:
        \begin{enumerate}
          \item Retrieve a Presentation Token Description Building Block from the ZkModuleFactory.
          \item Create a ZkModuleProver using the Building Block. Set the name of the ZkModule to
            \texttt{param:pt}.
          \item Note that the presentation token description was already updated by the upper layers
            and is not changed by the Crypto engine.
        \end{enumerate}
      \item Call the Zk Proof Engine with the list of ZkModuleProver that was generated. Receive
        a Zero-Knowledge Proof.
      \item Create a new PresentationToken. Copy the old Presentation Token Description to it.
        Add the Mechanism Specification and the Zero-Knowledge Proof to its Crypto Params.
      \item For each pseudonym:
        \begin{enumerate}
          \item Recover the value of the pseudonym from the corresponding ZkModuleProver. Update the new PresentationToken.
        \end{enumerate}
      \item For each inspectable attribute:
        \begin{enumerate}
          \item Recover the value of the ciphertext from the corresponding ZkModuleProver. Update the new PresentationToken.
        \end{enumerate}
      \item (For revealed attributes, the upper layer already took care of putting the actual attribute value in the PresentationToken.)
    \end{enumerate}

  \subsection{Proof Assembler (verifier)}
    The Proof Assembler receives a Presentation Token as input from the upper layers. This
    Presentation Token is split into The Presentation Token Description, a Mechanism Specification,
    and a Zero-Knowledge Proof.

    The role of the Proof Assembler is to create a list of ZkModuleVerifier that mirrors the list
    that the prover generated. The Proof Assembler is responsible for ensuring that the data inside the
    PresentationTokenDescription corresponds to the data inside the Proof (typically this is done by
    correctly initializing the ZkModules).
    The Proof Assembler reads the Mechanism Specification to determine which implementation of a building
    block was chosen by the prover. It queries the Building Block Factory to get a Building Blocks of the correct implementation.
    These Building Blocks then create the requisite ZkModuleVerifier; the Proof Assembler injects
    the Smartcard Helper into these ZkModuleProvers if necessary;
    the Proof Assembler also queries the Key Manager for parameters and public keys.

    The list of ZkModuleVerifier and the Zero-Knowledge Proof is passed to the Proof Engine.

    The Proof Assembler is implementation agnostic.

    Concretely, the proof assembler does the following:
    \begin{enumerate}
      \item Check that the system parameter UID and proof system UID in the Mechanism Specification are correct.
      \item Go though the list of credentials and pseudonyms to learn their aliases.
      \item Process the list of messages in the presentation token description:
        \begin{enumerate}
          \item Retrieve a Message Building Block from the ZkModuleFactory.
          \item Create a ZkModuleVerifier using the Building Block. Set the name of the ZkModule to
            \texttt{msg:n} if this is the $(n+1)$st message in the list.
        \end{enumerate}
      \item Process the list of pseudonyms in the presentation token description:
        \begin{enumerate}
          \item Retrieve the pseudonym value from the Presentation Token Description.
          \item Retrieve a Pseudonym Building Block with the implementation indicated in the mechanism spec from the ZkModuleFactory.
          \item Create a ZkModuleVerifier using the Building Block. Set the name of the ZkModule to
            \texttt{nym:n} if this is the $(n+1)$st pseudonym in the list.
          \item If there is a same key binding as clause:
            \begin{enumerate}
              \item Retrieve an AttributeEquality Block from the ZkModuleFactory.
              \item Create a ZkModuleVerifier using the Building Block. Set the name of the ZkModule to
                \texttt{eq:secret:nym:n} if this is the $(n+1)$st pseudonym in the list.
            \end{enumerate}
        \end{enumerate}
      \item Process the list of credentials in the presentation token description:
        \begin{enumerate}
          \item Fetch the credential specification from the Key Manager.
          \item Fetch the issuer's public key from the Key Manager.
          \item Retrieve a Credential Specification Building Block from the ZkModuleFactory. Determine the unique identifier
            of the credential specification. Create a ZkModuleVerifier using this Building Block. Set the name of the ZkModule to
            \texttt{sig:n:cs} if this is the $(n+1)$st credential in the list.
          \item Retrieve a Issuer Public Key Building Block from the ZkModuleFactory.
            Create a ZkModuleProver using this Building Block and load it with the key. Set the name of the ZkModule to
            \texttt{sig:n:ip} if this is the $(n+1)$st credential in the list.
          \item Retrieve a Privacy-ABC Signature Building Block with the implementation indicated in the issuer's key from the ZkModuleFactory.
          \item Create a ZkModuleVerifier for presentation using the Building Block. Set the name of the ZkModule to
            \texttt{sig:n} if this is the $(n+1)$st credential in the list.
          \item If the credential is revocable:
            \begin{enumerate}
              \item Fetch the public key of the revocation authority from the Key Manager.
              \item Retrieve a Revocation Building Block with the implementation indicated in the revocation authority's key from the ZkModuleFactory.
              \item Create a ZkModuleVerifier for presentation using the Building Block. Set the name of the ZkModule to
                \texttt{sig:n:rev} if this is the $(n+1)$st credential in the list.
              \item Retrieve a Revocation Authority Public Key Building Block from the ZkModuleFactory.
                Create a ZkModuleProver using this Building Block and load it with the key. Set the name of the ZkModule to
                \texttt{sig:n:rev:key:inspectorKey} if this is the $(n+1)$st credential in the list.
            \end{enumerate}
          \item For all revealed attributes in the credential:
            \begin{enumerate}
              \item Retrieve the value of the attribute from the Presentation Token Description.
              \item Retrieve a Reveal Attribute Block from the ZkModuleFactory.
              \item Create a ZkModuleVerifier using the Building Block. Set the name of the ZkModule to
                \texttt{reveal:n:m} if this is the $(m+1)$st DisclosedAttribute element of the $(n+1)$st credential in the list.
            \end{enumerate}
          \item For all inspectable attributes in the credential:
            \begin{enumerate}
              \item Retrieve the ciphertext from the Presentation Token Description.
              \item Retrieve the inspector's public key from the Key Manager.
              \item Retrieve an Inspection Block with the implementation indicated in the inspector's key from the ZkModuleFactory.
              \item Create a ZkModuleVerifier for encryption using the Building Block. Set the name of the ZkModule to
                \texttt{sig:n:ins:m} if this is the $(m+1)$st DisclosedAttribute element of the $(n+1)$st credential in the list.
              \item Retrieve a Inspector Public Key Building Block from the ZkModuleFactory.
                Create a ZkModuleProver using this Building Block and load it with the key. Set the name of the ZkModule to
                \texttt{sig:n:ins:m:inspectorKey} if this is the $(m+1)$st DisclosedAttribute element of the $(n+1)$st credential in the list.
            \end{enumerate}
          \item If there is a same key binding as clause:
            \begin{enumerate}
              \item Retrieve an AttributeEquality Block from the ZkModuleFactory.
              \item Create a ZkModuleVerifier using the Building Block. Set the name of the ZkModule to
                \texttt{eq:secret:sig:n} if this is the $(n+1)$st credential in the list.
            \end{enumerate}
        \end{enumerate}
      \item Process the list of predicates in the proof:
        \begin{enumerate}
          \item For each constant argument:
            \begin{enumerate}
              \item Retrieve a Constant Attribute Building Block from the ZkModuleFactory.
              \item Create a ZkModuleVerifier using the Building Block. Set the name of the ZkModule to
                \texttt{constant:n:m} if this is the $(m+1)$st argument of the $(n+1)$st predicate.
            \end{enumerate}
          \item If the function calls for a not-equal proof: \notimplemented
            \begin{enumerate}
              \item Retrieve a Not-Equal Proof Building Block using the implementation specified by the Mechanism Specification from the ZkModuleFactory.
              \item Create a ZkModuleVerifier using the Building Block. Set the name of the ZkModule to
                \texttt{ne:n} if this is the $(n+1)$st predicate.
            \end{enumerate}
          \item If the function calls for an inequality proof:
            \begin{enumerate}
              \item Retrieve an Inequality Proof Building Block using the implementation specified by the Mechanism Specification from the ZkModuleFactory.
              \item Create a ZkModuleVerifier using the Building Block. Set the name of the ZkModule to
                \texttt{ineq:n} if this is the $(n+1)$st predicate.
            \end{enumerate}
          \item If the function calls for an equality proof:
            \begin{enumerate}
              \item Retrieve an Attribute Equality Building Block from the ZkModuleFactory.
              \item Create a ZkModuleVerifier using the Building Block. Set the name of the ZkModule to
                \texttt{eq:n} if this is the $(n+1)$st predicate.
            \end{enumerate}
          \item If the function calls for a one-of proof (for a datatype that uses prime encoding): \notimplemented
            \begin{enumerate}
              \item Retrieve a Set Membership Building Block using the implementation specified by the Mechanism Specification from the ZkModuleFactory.
              \item Create a ZkModuleVerifier using the Building Block. Set the name of the ZkModule to
                \texttt{setmem:n} if this is the $(n+1)$st predicate.
            \end{enumerate}
        \end{enumerate}
      \item Add the system parameters:
        \begin{enumerate}
          \item Retrieve the System Parameters from the KeyManager.
          \item Retrieve a Parameters Building Block from the ZkModuleFactory.
          \item Create a ZkModuleVerifier using the Building Block. Set the name of the ZkModule to
            \texttt{param:sp}.
        \end{enumerate}
      \item Add the verifier parameters:
        \begin{enumerate}
          \item Retrieve a Parameters Building Block from the ZkModuleFactory.
          \item Create a ZkModuleVerifier using the Building Block. Set the name of the ZkModule to
            \texttt{param:vp}.
        \end{enumerate}
      \item Add the mechanism specification:
        \begin{enumerate}
          \item Retrieve a Mechanism Specification Building Block from the ZkModuleFactory.
          \item Create a ZkModuleVerifier using the Building Block. Set the name of the ZkModule to
            \texttt{param:ms}.
        \end{enumerate}
      \item Add the presentation token description:
        \begin{enumerate}
          \item Retrieve a Presentation Token Description Building Block from the ZkModuleFactory.
          \item Create a ZkModuleVerifier using the Building Block. Set the name of the ZkModule to
            \texttt{param:pt}.
        \end{enumerate}
      \item Call the Zk Proof Engine with the list of ZkModuleVerifier that was generated. Return true if
        the proof was verified successfully.
    \end{enumerate}

  \subsection{Issuance Orchestration (recipient)}
  The issuance protocol operates in three phases (plus a preparation phase for the issuer). In the first phase, the recipient and the issuer need to agree
  on jointly-random values (as specified by the issuance specification).
  In the second phase, the recipient and issuer do a presentation proof.
  In the third phase, the issuer signs the new credential (possibly in a multi-round protocol) and the recipient
  saves it in his credential store.
  Phase 1 is skipped if there is no need to generate jointly-random values. The first two phases are skipped if no attributes are
  carried over and if no presentation proof is necessary (``simple issuance'').

  \subsubsection{Initialize issuance}
  Upon being called through \texttt{initializeIssuance}, the module does the following:
  \begin{enumerate}
    \item Assert that the issuance message contains an issuance policy.
    \item Assert that the state storage has not yet seen the context.
    \item If this is a ``simple issuance'', proceed with the instructions of the third phase;
      else if the policy contains no jointly random attributes, proceed with the instructions of the second phase; else proceed with the instructions
      of the first phase.
  \end{enumerate}
  Upon being called through \texttt{continueIssuance}, the module does the following:
  \begin{enumerate}
  \item Assert that the issuance messages does not contain an issuance policy.
  \item Retrieve the next expected phase, the issuance policy, the verifier parameters, the list of credential URIs, the list of
    pseudonym URIs, the list of self claimed attributes, and some phase-dependant state object from the state storage (using the context as field).
    Delete the record from the state storage.
  \end{enumerate}


  \subsubsection{First phase, first round: joint-random attributes}
  \notimplemented
  \begin{enumerate}
    \item Initialize the ZkModuleFactory with the verifier parameters.
    \item For each jointly-random attribute in the credential template:
      \begin{enumerate}
        \item Fetch a Joint-Random building block from the factory.
        \item Check the number of preliminary rounds of communication needed.
        \item Create a new JointRandomStateRecipient.
        \item Call preliminaryRoundRecipient, and save the return value in a list. If this is the $(n+1)$st Joint-Random attribute,
          set the name of the module to \texttt{jr:0:n}.
        \item Also save the implementation type of the building block in a list.
      \end{enumerate}
      \item If all Joint-Random building blocks need only one roundtrip, the next expected state will be ``second phase'', else
        it will be ``first phase, second round''.
      \item Save the list of JointRandomStateRecipient, and the list of implentation types as the phase-dependant state object.
      \item Save the next expected phase, the issuance policy, verifier parameters, list of credential URIs, the list of
        pseudonym URIs, the list of self-claimed attributes, and the phase-dependant state object to the state storage (using the context as field).
      \item Wrap all the JointRandomMessageToIssuer and the list of implementation types in an IssuanceMessage, and return it.
  \end{enumerate}

  \subsubsection{First phase, subsequent rounds: joint-random attributes}
  \notimplemented
  \begin{enumerate}
    \item Initialize the ZkModuleFactory with the verifier parameters.
    \item For each jointly-random attribute in the credential template:
      \begin{enumerate}
        \item Recover the JointRandomStateRecipient and the implementation type from the phase-dependant state object.
        \item Fetch a Joint-Random building block of the correct implementation type from the factory.
        \item If this building block has not performed all of its communication rounds yet, call preliminaryRoundRecipient and
          save the return value in a list.
      \end{enumerate}
      \item If all Joint-Random building blocks have performed all of their roundtrips, the next expected state will be ``second phase'', else
        it will be ``first phase, $(n+1)$st round'' (where $n$ is the current round number).
      \item Save the list of all (updated or not) JointRandomStateRecipient, and the list of implementation types as the phase-dependant state object.
      \item Save the next expected phase, the issuance policy, verifier parameters, list of credential URIs, the list of
        pseudonym URIs, the list of self-claimed attributes, and the phase-dependant state object to the state storage (using the context as field).
      \item Wrap all the JointRandomMessageToIssuer in an IssuanceMessage, and return it.
  \end{enumerate}

  \subsubsection{Second phase: presentation proof for carry-over}
  \begin{enumerate}
      \item Initialize the ZkModuleFactory with the verifier parameters.
      \item Create a new Mechanism Specification. Set the system parameters UID and the proof system UID fields.
      \item Go though the list of credentials and pseudonyms to learn their aliases.
      \item Process the list of messages in the presentation token description in the same way as for presentation.
      \item Process the list of pseudonyms in the presentation token description in the same way as for presentation.
      \item Process the list of credentials in the presentation token description in the same way as for presentation.
      \item Process the credential template.
        \begin{enumerate}
          \item Fetch the credential specification from the Key Manager.
          \item Fetch the issuer's public key from the Key Manager.
          \item Retrieve a Credential Specification Building Block from the ZkModuleFactory. Determine the unique identifier
            of the credential specification. Create a ZkModuleProver using this Building Block. Set the name of the ZkModule to
            \texttt{newcred:0:cs}.
          \item Retrieve a Issuer Public Key Building Block from the ZkModuleFactory.
            Create a ZkModuleProver using this Building Block and load it with the key. Set the name of the ZkModule to
            \texttt{newcred:0:ip}.
          \item Retrieve a Privacy-ABC Signature Building Block with the same implementation as the credential from the ZkModuleFactory.
          \item Create a ZkModuleProver for carry over using the Building Block. Set the name of the ZkModule to
            \texttt{newcred:0}.
          \item For all jointly random attributes in the credential: \notimplemented
            \begin{enumerate}
              \item Recover the JointRandomStateRecipient and the implementation type from the phase-dependant state object.
              \item Fetch a Joint-Random building block of the correct implementation type from the factory.
              \item Create a ZkModuleProver using the Building Block. Set the name of the ZkModule to
                \texttt{jr:0:n} if this is the $(n+1)$st joint random attribute.
            \end{enumerate}
          \item For each carried over attribute:
            \begin{enumerate}
              \item Retrieve an AttributeEquality Block from the ZkModuleFactory.
              \item Create a ZkModuleProver using the Building Block. Set the name of the ZkModule to
                \texttt{eq:sig:newcred:0:n} if this is the $(n+1)$st carried over attribute.
            \end{enumerate}
          \item If there is a same key binding as clause:
            \begin{enumerate}
              \item Retrieve an AttributeEquality Block from the ZkModuleFactory.
              \item Create a ZkModuleProver using the Building Block. Set the name of the ZkModule to
                \texttt{eq:secret:sig:newcred:0}.
            \end{enumerate}
        \end{enumerate}
      \item Process the list of predicates in the proof in the same way as for presentation.
      \item Add the system parameters in the same way as for presentation.
      \item Add the verifier parameters in the same way as for presentation.
      \item Add the mechanism specification in the same way as for presentation.
      \item Call the Zk Proof Engine with the list of ZkModuleProver that was generated. Receive
        a Zero-Knowledge Proof.
      \item Create a new IssuanceToken. Copy the old Issuance Token Description to it.
        Add the Mechanism Specification and the Zero-Knowledge Proof to its Crypto Params.
      \item For each pseudonym:
        \begin{enumerate}
          \item Recover the value of the pseudonym from the corresponding ZkModuleProver. Update the new IssuanceToken.
        \end{enumerate}
      \item For each inspectable attribute:
        \begin{enumerate}
          \item Recover the value of the ciphertext from the corresponding ZkModuleProver. Update the new IssuanceToken.
        \end{enumerate}
      \item (For revealed attributes, the upper layer already took care of putting the actual attribute value in the IssuanceToken.)
      \item Recover the CarryOverStateRecipient from the carry-over ZkModuleProver; (if applicable) retrieve the URI of the smartcard the new credential
            must be bound to; and save both as the phase-dependant state object.
      \item Set the next expected phase to ``third phase, 1st round''.
      \item Save the next expected phase, the issuance policy, verifier parameters, list of credential URIs, the list of
        pseudonym URIs, the list of self-claimed attributes, and the phase-dependant state object to the state storage (using the context as field).
      \item Wrap the IssuanceToken in an issuance message, and return it.
    \end{enumerate}

  \subsubsection{Third phase round 1: interactive signing of new credential}
  \begin{enumerate}
  \item Unwrap the proof and mechanism specification from the Issuance Message.
  \item Unwrap the CarryOverStateRecipient and URI of the smartcard from the phase-dependant state object.
  \item Check that the system parameter UID and proof system UID in the mechanism specification is correct.
  \item Fetch the credential specification, the issuer public key, the system parameters from the key manager.
  \item Retrieve a Credential Specification Building Block from the ZkModuleFactory. Determine the unique identifier
    of the credential specification. Create a ZkModuleVerifier using this Building Block. Set the name of the ZkModule to
    \texttt{newcred:0:cs}.
  \item Retrieve a Issuer Public Key Building Block from the ZkModuleFactory.
    Create a ZkModuleVerifier using this Building Block and load it with the key. Set the name of the ZkModule to
    \texttt{newcred:0:ip}.
  \item Retrieve a Privacy-ABC Signature Building Block with the implementation indicated in the issuer's public key from the factory.
  \item Create a ZkModuleVerifier for issuance. Set the name to \texttt{newcred:0}.
  \item If the credential is revocable:
    \begin{enumerate}
      \item Retrieve the public key of the revocation authority from the key manager.
      \item Retrieve a Revocation Building Block of the appropriate implementation from the factory.
      \item Create a ZkModuleVerifier for issuance. Set the name to \texttt{rev:0}. Make sure that the idOfRHAttribute
        references the correct attribute in the signature ZkModuleVerifier.
    \end{enumerate}
  \item Retrieve a Mechanism Specification Building Block from the ZkModuleFactory.
  Create a ZkModuleVerifier using the Building Block. Set the name of the ZkModule to
  \texttt{ms}.
  \item Call the ZkProofEngine with the list of ZkModuleVerifier that was generated. (Abort if proof verification fails.)
  \item Retrieve the IssuanceStateRecipient from the signature Building Block.
  \item If applicable, retrieve the NonRevocationEvidence from the revocation building block.
  \item Determine how many extra issuance rounds are needed for the current signature scheme. If it's zero, then follow the
    instructions below in ``Extract credential'' starting at step 4. If it's non zero, follow the instructions in ``Third phase additional rounds'' starting at step 4.
  \end{enumerate}

  \subsubsection{Third phase additional rounds}
  \begin{enumerate}
    \item Extract the IssuanceMessageFromIssuer from the Issuance Message.
    \item Extract the IssuanceStateRecipient, CarryOverStateRecipient, NonRevocationEvidence, URI of smartcard from the phase-dependant state object.
    \item Fetch the system parameters, issuer parameters, credential specification from the key manager.
    \item Retrieve a Credential Specification Building Block from the ZkModuleFactory. Determine the unique identifier
      of the credential specification.
    \item Retrieve a Privacy-ABC Signature Building Block of the correct implementation from the factory.
    \item Call extraIssuanceRoundRecipient().
    \item Save the new IssuanceStateRecipient, CarryOverStateRecipient, NonRevocationEvidence, URI of smartcard in the phase-dependant state object.
    \item If there are issuance rounds remaining, set the next expected phase to ``Third phase, round $n$'' (where $n-1$ is the
       current round number); else set it to ``Extract credential''.
    \item Save the next expected phase, the issuance policy, verifier parameters, list of credential URIs, the list of
      pseudonym URIs, the list of self-claimed attributes, and the phase-dependant state object to the state storage (using the context as field).
    \item Wrap the IssuanceMessageToIssuer in an IssuanceMessage and return it.
  \end{enumerate}

  \subsubsection{Extract credential}
  \begin{enumerate}
    \item Extract the IssuanceMessageFromIssuer from the Issuance Message.
    \item Extract the IssuanceStateRecipient, CarryOverStateRecipient, NonRevocationEvidence, URI of smartcard from the phase-dependant state object.
    \item Fetch the system parameters, issuer parameters, credential specification from the key manager.
    \item Retrieve a Privacy-ABC Signature Building Block of the correct implementation from the factory.
    \item Call extractSignature().
    \item Populate the new credential with the returned signature, list of attribute values, non-revocation evidence, and any binding info for external secrets.
    \item Save the new credential in the credential manager. Return the credential description of the new credential.
  \end{enumerate}

  \subsection{Issuance Orchestration (issuer)}
  Upon being called though \texttt{initializeIssuance}, the module does the following:
  \begin{enumerate}
    \item If the context is NULL, generate a random context. Otherwise, assert that the context has never been seen by the state storage.
    \item If it is detected that this is a ``simple issuance'', proceed with the instructions of the third step below.
    \item Otherwise
    \begin{enumerate}
      \item Initialize a variable holding the next expected step.
        If the policy contains no jointly random attributes, the next expected step will be ``second phase''; else the next expected phase will
        be ``first phase''.
      \item Store the next expected step, the issuance policy, the verifier parameters, the list of attributes, and a NULL-value
        (representing the phase-dependant state object) in the state storage (using the context as field value).
      \item Wrap the issuance policy, the verifier parameters, and the context
        in an issuance message.
      \item Return this issuance message, false (indicating that this is not the last message), and a NULL-valued URI (representing the absence of log entries).
    \end{enumerate}
  \end{enumerate}
  Upon being called though \texttt{continueIssuance}, the module does the following:
  \begin{enumerate}
  \item Retrieve the next expected phase, the issuance policy, the verifier parameters, the list of attributes,
    and some phase-dependant state object from the state storage (using the context as field).
    Delete the record from the state storage.
  \item Proceed with the instructions for the next expected phase.
  \end{enumerate}

  \subsubsection{First phase, first round: joint-random attributes}
  \notimplemented
  \begin{enumerate}
    \item Initialize the ZkModuleFactory with the verifier parameters.
    \item For each jointly-random attribute in the credential template:
      \begin{enumerate}
        \item Parse the implementation type of the Joint-Random block from the Issuance message.
        \item Fetch a Joint-Random building block of the correct implementation from the factory.
        \item Check the number of preliminary rounds of communication needed.
        \item Create a new JointRandomStateIssuer.
        \item Call preliminaryRoundIssuer, and save the return value in a list. If this is the $(n+1)$st Joint-Random attribute,
          set the name of the module to \texttt{jr:0:n}.
      \end{enumerate}
      \item If all Joint-Random building blocks need only one roundtrip, the next expected state will be ``second phase'', else
        it will be ``first phase, second round''.
      \item Save the list of JointRandomStateIssuer, and the list of implentation types as the phase-dependant state object.
      \item Save the next expected phase, the issuance policy, verifier parameters, list of attributes,
      and the phase-dependant state object to the state storage (using the context as field).
      \item Wrap all the JointRandomMessageToRecipient in an IssuanceMessage, and return it.
  \end{enumerate}

  \subsubsection{First phase, subsequent rounds: joint-random attributes}
  \notimplemented
  \begin{enumerate}
    \item Initialize the ZkModuleFactory with the verifier parameters.
    \item For each jointly-random attribute in the credential template:
      \begin{enumerate}
        \item Recover the JointRandomStateIssuer and the implementation type from the phase-dependant state object.
        \item Fetch a Joint-Random building block of the correct implementation from the factory.
        \item If this building block has not performed all of its communication rounds yet, call preliminaryRoundIssuer and
          save the return value in a list.
      \end{enumerate}
      \item If all Joint-Random building blocks have performed all of their roundtrips, the next expected state will be ``second phase'', else
        it will be ``first phase, $(n+1)$st round'' (where $n$ is the current round number).
      \item Save the list of all (updated or not) JointRandomStateIssuer, and the list of implementation types as the phase-dependant state object.
      \item Save the next expected phase, the issuance policy, verifier parameters, list of attributes,
        and the phase-dependant state object to the state storage (using the context as field).
      \item Wrap all the JointRandomMessageToRecipient in an IssuanceMessage, and return it.
  \end{enumerate}

  \subsubsection{Second phase: presentation proof for carry-over}
    \begin{enumerate}
      \item Recover the issuance token from issuance message. Recover the proof and mechanism specification from the crypto evidence.
      \item Pass the issuance token to the upper-layer policy token matcher. (Abort if the token does not verify.)
      \item Check that the system parameter UID and proof system UID in the Mechanism Specification are correct.
      \item Go though the list of credentials and pseudonyms to learn their aliases.
      \item Process the list of messages in the presentation token description, as for presentation.
      \item Process the list of pseudonyms in the presentation token description, as for presentation.
      \item Process the list of credentials in the presentation token description, as for presentation.
      \item Process the credential template:
        \begin{enumerate}
          \item Fetch the credential specification from the Key Manager.
          \item Fetch the issuer's public key (= own public key) from the Key Manager.
          \item Retrieve a Issuer Public Key Building Block from the ZkModuleFactory.
            Create a ZkModuleProver using this Building Block and load it with the key. Set the name of the ZkModule to
            \texttt{newcred:0:ip}.
          \item Retrieve a Credential Specification Building Block from the ZkModuleFactory. Determine the unique identifier
            of the credential specification. Create a ZkModuleVerifier using this Building Block. Set the name of the ZkModule to
            \texttt{newcred:0:cs}.
          \item Retrieve a Privacy-ABC Signature Building Block with the implementation indicated in the issuer's key from the ZkModuleFactory.
          \item Create a ZkModuleVerifier for carry-over using the Building Block. Set the name of the ZkModule to
            \texttt{newcred:0}.
          \item For all jointly random attributes in the credential: \notimplemented
          \begin{enumerate}
            \item Recover the JointRandomStateIssuer and the implementation type from the phase dependant state object.
            \item Fetch a Joint-Random building block of the correct implementation type from the factory.
            \item Create a ZkModuleVerfier using the Building Block. Set the name of the ZkModule to \texttt{jr:0:n} if
              this is the $(n+1)$st joint random attribute.
          \end{enumerate}
          \item For each carried over attribute:
            \begin{enumerate}
              \item Retrieve an AttributeEquality Block from the ZkModuleFactory.
              \item Create a ZkModuleVerifier using the Building Block. Set the name of the ZkModule to
                \texttt{eq:sig:newcred:0:n} if this is the $(n+1)$st carried over attribute in the list.
            \end{enumerate}
          \item If there is a same key binding as clause:
            \begin{enumerate}
              \item Retrieve an AttributeEquality Block from the ZkModuleFactory.
              \item Create a ZkModuleVerifier using the Building Block. Set the name of the ZkModule to
                \texttt{eq:secret:sig:newcred:0}.
            \end{enumerate}
        \end{enumerate}
      \item Process the list of predicates in the proof, as for presentation.
      \item Add the system parameters, as for presentation.
      \item Add the verifier parameters, as for presentation.
      \item Add the mechanism specification, as for presentation.
      \item Call the Zk Proof Engine with the list of ZkModuleVerifier that was generated. (Abort if verification fails.)

      \item Start the process to sign the new credential:
      \begin{enumerate}
      \item Create a new Mechanism Specification. Set the system parameters UID and the proof system UID fields.
      \item Retrieve a Privacy-ABC Signature Building Block with the implementation of its own issuer public key.
      \item Retrieve own secret key from the CredentialStorage.
      \item Retrieve a Credential Specification Building Block from the ZkModuleFactory. Determine the unique identifier
        of the credential specification. Create a ZkModuleProver using this Building Block. Set the name of the ZkModule to
        \texttt{newcred:0:cs}.
      \item Retrieve a Issuer Public Key Building Block from the ZkModuleFactory.
        Create a ZkModuleProver using this Building Block and load it with the key. Set the name of the ZkModule to
        \texttt{newcred:0:ip}.
      \item Create a ZkModuleProver for issuance. Set the name to \texttt{newcred:0}.
      \item If the credential to issue is revocable:
      \begin{enumerate}
        \item Retrieve the public key of the revocation authority from the key manager.
        \item Retrieve a Revocation Building Block with the implementation specified by the revocation authority key.
        \item Create a ZkModuleProver for issuance. Set the name to \texttt{rev:0}. (At this point in time, this ZkModuleProver
          contacts the revocation authority via the revocation proxy to get a new revocation handle and associated
          non-revocation evidence.) Make sure that the idOfRHAttribute references the correct attribute in the signature ZkModuleProver.
      \end{enumerate}
      \item Retrieve a Mechanism Specification Building Block from the ZkModuleFactory.
      Create a ZkModuleProver using the Building Block. Set the name of the ZkModule to
      \texttt{ms}.
      \item Call the Zk Proof Engine with the list of ZkModuleProver that was generated. Receive a Zero-Knowledge proof.

      \item If the number of additional issuance rounds for the Privacy-ABC Signature Building Block is non-zero:
        \begin{enumerate}
        \item Set the next expected phase to ``third phase, round 1''.
        \item Recover the IssuanceStateIssuer from the issuance ZkModule. Save the IssuanceStateIssuer and CarryOverStateIssuer in the phase-dependant state object.
        \item Save the next expected phase, the issuance policy, verifier parameters, list of attributes,
          and the phase-dependant state object to the state storage (using the context as field).
        \end{enumerate}
      \item Recover the list of attributes from the signature issuance ZkModuleProver, generate an issuance log entry and store it in the TokenManagerIssuer.
      \item Wrap the zero-knowledge proof and the mechanism specification in an issuance message. Return the issuance message and the URI of the log entry.
      \end{enumerate}
    \end{enumerate}


  \subsubsection{Third phase: interactive signing of new credential}
  \begin{enumerate}
  \item Recover the IssuanceStateIssuer and CarryOverStateIssuer from the phase-dependant state object.
  \item Recover the messageFromRecipient from the IssuanceMessage.
  \item Fetch the system parameters, the own public key, and the credential spec from the KeyManager
  \item Retrieve a Credential Specification Building Block from the ZkModuleFactory. Determine the unique identifier
    of the credential specification.
  \item Fetch the own secret key from the credential manager.
  \item Fetch a signature Building Block of the correct implementation from the factory.
  \item Call extraIssuanceRoundIssuer().
  \item If there are additional issuance rounds left:
    \begin{enumerate}
      \item Set the next expected phase to ``third phase, round $n$'' where $(n-1)$ is the current round.
      \item Save the updated IssuanceStateIssuer and CarryOverStateIssuer in the phase-dependant state object.
      \item Save the next expected phase, the issuance policy, verifier parameters, list of attributes,
          and the phase-dependant state object to the state storage (using the context as field).
    \end{enumerate}
  \item Wrap the IssuanceMessageToRecipient in an IssuanceMessage, and return it.
  \end{enumerate}

  \subsection{Proof Engine (prover)}
  The Proof Engine (prover) is responsible for orchestrating the construction of a zero-knowledge proof (Fiat-Shamir heuristic).
  We use the Builder pattern: the client is the Proof Assembler or Issuance Orchestration, the director is a class called ZkDirector,
  the builder is a ZkBuilder, and the product is a ZkProof.

  The proof is built from a list of zkModuleProver. A proof is built in several steps. During each step, a ``firewalled'' version
  of the zkBuilder provides and collects relevant information from each zkModuleProver.

  \subsubsection{Terminology}
  \label{zkproof:terminology}
  We use the following terminology for values inside the zero-knowledge engine:

  \begin{tabular}{|l|p{0.8\textwidth}|}\hline
  \textbf{Name} & \textbf{Explanation} \\\hline
  T-value & Commi\textbf{t}ment values. The values that are sent out in the first message of a $\Sigma$-protocol.\\\hline
  S-value & Re\textbf{s}ponse values. The values that are sent out in the third message of a $\Sigma$-protocol.\\\hline
  R-value & \textbf{R}andomizers. The random values that replace the attribute values when computing the T-values.\\\hline
  D-value & \textbf{D}elivered values. Values (including revealed attributes) that are sent to the verifier together with the proof,
  and that contribute to the challenge of the Fiat-Shamir construction.\\\hline
  N-value & Co\textbf{n}text values. Values that the prover and the verifier agree on during the proof and that don't need to
  be transmitted to the verifier. These values also contribute to the challenge of the Fiat-Shamir construction.\\\hline
  \end{tabular}

  \subsubsection{zkBuilder}
  The zkBuilder is responsible for keeping track of which attributes are revealed or not; determining the order in which the
  zkModules must be processed to ensure availability of all the attribute values in time; collecting T-values, S-values,
  D-values and N-values; assigning R-values; computing the challenge;
  and serializing the proof object. (In order to accomplish these tasks, we implemented a union-find datastructure and a topological sort function.)

  In addition to the functions described in Section \ref{sec:intf:zkmoduleprover}, the zkBuilder supports the following functions:

  \begin{method}
  {List<String>}
  {topologicallySortModules}
  {
  }
  Returns a list of identifiers of ZkModules in an order that satisfies the following condition:
  \begin{itemize}
    \item If a module A \emph{requires} an attribute B, and a module C \emph{provides} that attribute B, then C comes before A.
  \end{itemize}
  If such an ordering does not exist, this function returns NULL.
  \end{method}

  \begin{method}
  {void}
  {assignRValues}
  {
  }
  When this function is called, the zkBuilder assigns R-values to all unrevealed attributes for which it knows the value.
  The R-value of all attributes in an equivalence class must be compatible (i.e., if two attributes are equal, their R-value
  must be the same; if there exists a linear relationship between attributes, then their R-value must also satisfy this
  linear relationship). The R-value for a given equivalence class are chosen independently uniformly at random within its domain
   from R-values in other equivalence classes.
  \end{method}

  \begin{method}
  {ZkProof}
  {assembleProof}
  {
  }
  When this function is called, the zkBuilder returns a ZkProof object containing: the challenge-with-nonce,
  the challenge-nonce, the sorted list of field-values pairs of S-values (sorted by field), the sorted list of
  field-value pairs of revealed attributes, the sorted list of field-value pairs for integer D-values,
  the sorted list of field-value pairs for non-integer D-values. Optionally, to assist with debugging, the ZkProof
  may also contain: a sorted list of field-value pairs of T-values, and a sorted list of field-value pairs of N-values.
  \end{method}

  Additionally, the following methods return ``firewalled'' versions of the ZkBuilder for a specific
  zkModule. The list of functions that
  are supported by the ``firewalled'' versions is described in Section \ref{sec:intf:zkmoduleprover}.

  \begin{method}
  {ZkBuilderStateInitialize}
  {getStateForInitialize}
  {
    {String zkModuleName}
  }
  \end{method}
  \begin{method}
  {ZkBuilderStateCollect}
  {getStateForCollect}
  {
    {String zkModuleName}
  }
  \end{method}
  \begin{method}
  {ZkBuilderStateFirst}
  {getStateForFirst}
  {
    {String zkModuleName}
  }
  \end{method}
  \begin{method}
  {ZkBuilderStateSecond}
  {getStateForSecond}
  {
    {String zkModuleName}
  }
  \end{method}

  \subsubsection{zkDirector}
  The zkDirector is responsible for calling methods on the list of zkModuleProver in the correct order (passing them the
  ``firewalled'' version of the zkBuilder as parameter). The zkDirector also interacts with the zkBuilder directly at certain
  points of the proof construction.

  The zkDirector operates as follows:
  \begin{enumerate}
    \item Receive a list of ZkModuleProver from the client.
    \item Initialize a ZkBuilder.
    \item For all ZkModuleProver:
      \begin{enumerate}
        \item Get a ZkBuilderStateInitialize for the given ZkModuleProver by calling getStateForInitialize(moduleName).
        \item Call initializeModule() on the ZkModuleProver, passing the ZkBuilderStateInitialize. In this phase, the ZkModuleProver
          informs the ZkBuilder of all attributes that it will use during the proof, and provide the value of some of these attributes
          to the ZkBuilder; it may declare that the value of some of these attributes depends on the value of other attributes (in which case,
          the ZkModuleProver must provide these values in the Collect phase (after the ZkModuleProver have been topologically sorted)).
      \end{enumerate}
    \item Call topologicallySortModules() on the zkBuilder. Re-order the list of ZkModuleProver according to the return value.
    \item Ask the factory for a Range Check Building Block.
    \item Extract a ZkBuilderStateCollect from the ZkBuilder.
    \item For all ZkModuleProver:
      \begin{enumerate}
        \item Get a ZkBuilderStateCollect for the given ZkModuleProver by calling getStateForCollect(moduleName).
        \item Call collectAttributesForProof() on the ZkModuleProver, passing the ZkBuilderStateCollect. In this phase, the ZkModuleProver
           provides the ZkBuilder with the value of attributes that depended on the value of attributes from other ZkModuleProvers.
      \end{enumerate}

    \item Call assignRValues() on the zkBuilder.
    \item For all ZkModuleProver:
      \begin{enumerate}
        \item Get a ZkBuilderStateFirst for the given ZkModuleProver by calling getStateForFirst(moduleName).
        \item Call firstRound() on the ZkModuleProver, passing the ZkBuilderStateFirst. In this phase, the ZkModuleProver generates T-values, D-values, N-values, and nonce commitments for all attributes on smartcard.
      \end{enumerate}

    \item Call computeChallenge() on the zkBuilder.
    \item For all ZkModuleProver:
      \begin{enumerate}
        \item Get a ZkBuilderStateSecond for the given ZkModuleProver by calling getStateForSecond(moduleName).
        \item Call secondRound() on the ZkModuleProver, passing the ZkBuilderStateSecond. In this phase, the ZkModuleProver generates S-values.
      \end{enumerate}

    \item Call assembleProof() on the zkBuilder, and return the ZkProof.
  \end{enumerate}

  \subsection{Proof Engine (verifier)}
  The Proof Engine (verifier) is responsible for orchestrating the verification of a zero-knowledge proof.
  We use the Builder pattern: the client is the Proof Assembler or Issuance Orchestration, the director is a class called ZkDirector,
  the builder is a ZkVerifier, and the product is a boolean indicating whether the proof verifies.

  The ZkProof is verified with help from a list of zkModuleVerifier. A proof is verified in two steps. During each step, a ``firewalled'' version
  of the zkVerifier provides and collects relevant information from each zkModuleVerifier.

  \subsubsection{zkVerifier}
  The zkVerifier performs a similar role as the zkBuilder during the proof.
  It is responsible for parsing the ZkProof; keeping track of which attributes are revealed or not;
  verifying that all T-values
  are correctly re-computed; ensuring that the hash contribution of all D-values and N-values are correct;
  checking that S-values are in the correct interval; ensuring that relations among S-values are correct;
  and re-computing the challenge.

  In addition to the functions described in Section \ref{sec:intf:zkmoduleverifier}, the zkVerifier supports the following functions:

  \begin{method}
  {boolean}
  {performIntegrityCheckOfSValues}
  {
  }
  When this method is called, the zkVerifier checks that all S-values are in their expected interval, and that
  all S-values within an equivalence class are compatible (i.e., S-values corresponding to attributes that are equal,
  must be equal). Return true if all these checks pass.
  \end{method}

  \begin{method}
  {boolean}
  {finalizeVerification}
  {
  }
  When this method is called, check that all T-values have been successfully re-computed, that the hash
  contribution of all non-integer D-values is correct, that the hash contribution of all N-values is correct,
  that the challenge-without-nonce is correct, and that the challenge-with-nonce is correct.
  Return true if all these tests pass.
  \end{method}

  Additionally, the following methods return ``firewalled'' versions of the ZkVerifier
  for a specific zkModule. The list of functions that
  are supported by the ``firewalled'' versions is described in Section \ref{sec:intf:zkmoduleverifier}.

  \begin{method}
  {ZkVerifierStateCollect}
  {getStateForCollect}
  {
    {String zkModuleName}
  }
  \end{method}
  \begin{method}
  {ZkVerifierStateFirst}
  {getStateForFirst}
  {
    {String zkModuleName}
  }
  \end{method}

  \subsubsection{zkDirector}
  The zkDirector is responsible for calling methods on the list of zkModuleVerifier in the correct order (passing them the
  ``firewalled'' version of the zkVerifier as parameter). The zkDirector also interacts with the zkVerifier directly at certain
  points of the proof verification.

  The zkDirector operates as follows:
  \begin{enumerate}
    \item Receive a list of ZkModuleVerifier, and a ZkProof from the client.
    \item Initialize a ZkVerifier with the ZkProof.
    \item For all ZkModuleVerifier:
      \begin{enumerate}
        \item Get a ZkBuilderStateCollect for the given ZkModuleVerifier by calling getStateForCollect(moduleName).
        \item Call collectAttributesForVerify() on the ZkModuleVerifier, passing the ZkVerifierStateCollect. In this phase, the ZkModuleVerifier
          informs the ZkVerifier of all attributes that were in use during the proof.
      \end{enumerate}

    \item Call performIntegrityCheckOfSValues() on the zkVerifier. Abort the verification if the return value was false.
    \item For all ZkModuleVerifier:
      \begin{enumerate}
        \item Get a ZkBuilderStateVerify for the given ZkModuleVerifier by calling getStateForVerify(moduleName).
        \item Call verify() on the ZkModuleVerifier, passing the ZkVerifierStateFirst. In this phase, the ZkModuleVerifier re-computes the T-values for all equations, checks
        the has contribution of D-values, checks the hash contribution of N-values, and performs implementation specific checks. If verify() returns false, then
        the director aborts the proof verification.
      \end{enumerate}

    \item Call finalizeVerification() on the zkVerifier. Return the result.
  \end{enumerate}

  \subsection{Computation of the challenge}
  We now describe how the crypto engine computes the value of the challenge for a given proof.
  In a nutshell, every ZkModule computes a so-called Hash Contribution that is based on its
  name, the revealed attributes it touched, and the list of its D-, N-, and T-value.
  The Hash Contributions of all ZkModules are then combined to compute the overall challenge.

  \subsubsection{Preliminaries}\label{ssec:challenge:prelim}
  Let \hashfunction denote the hash function specified in the system parameters. For example,
  \hashfunction could be SHA-256. It takes as input a bytestring and outputs a bytestring.

  We denote the concatenation of two bytestrings $a$ and $b$ as $a||b$.

  Let \intToBytes denote the function that takes as input an integer and returns
  the big-endian 2's complement representation of that integer over exactly 4 bytes.

  Let \stringToBytes denote the function that takes as input a string $s$ and outputs a bytestring
  $\intToBytes(s.length)||s$, i.e., the length of the string (over 4 bytes) concatenated
  with the string itself.

  Let \serializelist denote the function that takes a list of $n$ bytestrings
  $a_1, \ldots, a_n$ and outputs the following bytestring:
  $\intToBytes(n)||\stringToBytes(a_1)||\ldots||\stringToBytes(a_n)$.

  \subsubsection{Computation of the Hash Contribution of a ZkModule}
  Let $\textit{name}$ denote the name of the ZkModule as a UTF-8 encoded bytestring.

  Let $r_1, \ldots, r_m$ denote the list of revealed attributed that this ZkModule
  uses; this list is sorted alphabetically by the name of the local representative of each
  attribute and where attributes that share the same local representative appear only once.
  That is, if this ZkModule declares several attributes as being equal, the
  local representative of all of these attributes is the attribute whose name comes
  first lexicographically. (If several attributes are declared equal outside of this ZkModule,
  it does not affect the hash computation.)
  Each $r_i$ consists of the 2's complement big-endian representation of the integer value of
  the attribute.

  Let $d_1, \ldots, d_o$ denote the D-values used by this module sorted by name,
  let $n_1, \ldots, n_p$ denote the N-values used by this module sorted by name,
  and let $t_1, \ldots, t_q$ denote the T-values used by this module sorted by name (the name of a T-value usually corresponds to the name of the attribute it represents).
  These values are encoded as follows. If the value is a BigInteger, then the 2's complement big-endian representation of the
  integer value is used. If the value is already a bytestring it is left unmodified. If the value is a text string, then the UTF-8 representation
  of that string is used.
  If the value is a group element, then it is serialized depending on their concrete implementation (for example, both signed quadratic residues and prime-order group elements
  are treated like BigIntegers). Finally, it is also possible to specify a custom hash contribution for these values, in which case the hash contribution is used directly.

  The hash contribution of the ZkModule is then:
  \begin{align*}
  \textit{hashContribution} = \hashfunction\big(& \stringToBytes(\textit{name}) || \serializelist(d_1, \ldots, d_o) || \serializelist(r_1, \ldots, r_m) || \\&
    \serializelist(n_1, \ldots, n_p) || \serializelist(t_1, \ldots, t_q)\big)
  \end{align*}

  \subsubsection{Computation of the challenge for a proof}
  Let $(c_1, c_2, \ldots, c_n)$ denote the list of hash contributions of all ZkModules
  (excluding the ZkModule that don't have a hash contribution) sorted by their name.
  Let $i$ denote the first ZkModule presentation of a privacy-ABC signature (or $i=1$ if there is none).
  Then the challenge is computed as follows:
  \begin{align*}
  \textit{innerHash} &= \hashfunction(\serializelist(c_1, \ldots, c_{i-1}, c_{i+1}, \ldots, c_n))\\
  \textit{outerHash} &= \hashfunction(\serializelist(c_i, \textit{innerHash}))
  \end{align*}
  \textit{outerHash} is then converted to an unsigned integer (big Endian encoding) to yield the
  challenge.

  The rationale for having an inner and outer hash is to guarantee compatibility with the U-Prove library,
  which looks only at $c_i$.

  Note that the ZkModules are serialized in the order $c_i, c_1, \ldots, c_{i-1}, c_{i+1}, \ldots, c_n$
  in the proof XML.
