%!TEX root =  IdmxSpecification.tex

\section{Application Programming Interface (API)}
\label{sec:api}

In this section we describe the external interface of the Idmx library.
We provide access to the library using a crypto engine interface, where we offer distinct 
engines for each entity using the library.
Idmx makes use of functionality that has been implemented within the ABC4Trust project 
(published at: \url{https://github.com/p2abcengine/p2abcengine}), the so called \emph{ABC system}.
In Section \ref{sec:api:dep} we discuss the dependencies on this ABC system, which is followed by
our desctiption of the external API of the library (Sec.~\ref{sec:api:interface}).



  \subsection{Dependencies}
  \label{sec:api:dep}
  During its operation, the Idmx library will need to make calls to components 
  specified and implemented within the the ABC system.
  These components must be passed to the library when it is being initialized,
  for example by using dependency injection.
  In this section we list the components that the crypto engines of the different entities depend on.

  \subsubsection{User's Crypto Engine}
  
  Note that we provide two separate engines for the role of a recipient of a credential 
  and the role of a prover of properties about credentials.
  In many scenarios a user assumes these two roles and for this reason we describe them 
  together.
  
  \begin{itemize}
    \item CredentialManager (user)---The credential manager provides credentials and pseudonyms to the crypto engine.
    \item KeyManager---The key manager provides authenticated public keys, parameters, revocation information, and credential specifications
      to the crypto engine.
    \item RevocationProxy---The revocation authority provides the latest revocation information and can update non-revocation information
      for the crypto engine via the revocation proxy (over a secure channel).
    \item SmartcardManager---The smartcard manager helps the crypto engine conduct proofs involving device-bound credentials and pseudonyms. It
    is assumed that the smartcard manager has been properly initialized (by the credential manager) before the crypto engine is asked to
    conduct a presentation or issuance proof.
  \end{itemize}

  \subsubsection{Verifier's Crypto Engine}
  \begin{itemize}
    \item KeyManager---The key manager provides authenticated public keys, parameters, revocation information, and credential specifications
      to the crypto engine.
    \item RevocationProxy---The revocation authority provides the latest revocation information to the crypto engine via the revocation proxy (over a secure channel).
  \end{itemize}

  \subsubsection{Issuer's Crypto Engine}
  \begin{itemize}
    \item CredentialManager (issuer)---The credential manager provides the issuer's secret key to the crypto engine.
    \item KeyManager---The key manager provides authenticated public keys, parameters, revocation information, and credential specifications
      to the crypto engine. Note that fetching the revocation information may invoke the RevocationProxy (e.g., for retrieving the latest version).
    \item RevocationProxy---The revocation authority provides the latest revocation information, can update non-revocation information,
      and can provide a new revocation handle with associated non-revocation information
      to the crypto engine via the revocation proxy (over a secure channel).
%     \item TokenManager (issuer)---The token manager stores the issuance tokens that come up during the proof, and stores log entries for each issuance of
%       a credential. The crypto architecture is responsible for storing the token and log entries.
  \end{itemize}

  \subsubsection{Inspector's Crypto Engine}
  \begin{itemize}
    \item CredentialManager (inspector)---The credential manager provides the inspector's secret key to the crypto engine.
    \item KeyManager---The key manager provides authenticated public keys, parameters, revocation information, and credential specifications
      to the crypto engine.
  \end{itemize}

  \subsubsection{Revocation Authority's Crypto Engine}
  \begin{itemize}
    \item CredentialManager (revocation)---The credential manager provides the revocation authority with it's secret key. It also stores
      and retrieves the history of all revocation events, specific revocation events, and non-revocation evidences.
    \item KeyManager---The key manager provides authenticated public keys, parameters, revocation information, and credential specifications
      to the crypto engine.
  \end{itemize}


  \subsection{External API}
  \label{sec:api:interface}
  In this section we describe the external API of the different crypto engines that provide access to the Idmx library.
  We keep this section short, since most of it has already been covered by other ABC4Trust 
  documents~\cite{abc4trust:h22}.
  

  \subsubsection{User's Crypto Engine}
  
  As discussed before, a user most commonly acts as a recipient of a credential in an
  issuance protocol and thereafter she proves properties about the received credential, thereby acting
  as prover in a presentation protocol.
  Here we first describe the methods of the recipient crypto engine before detailling the prover 
  crypto engine.
  
  \paragraph{Recipient Crypto Engine}
% 	    IssuanceMessage preIssuancePresentation(IssuanceMessage issuanceMessage,
%       IssuanceTokenDescription issuanceTokenDescription, List<URI> listOfCredentialIds,
%       List<URI> listOfPseudonyms, List<Attribute> userProvidedAttributes)
	  \begin{method}
      {IssuanceMessage}
      {preIssuancePresentation}
      {
        {@in IssuanceMessage im}
        {@in IssuanceTokenDescription itd}
%         {@in VerifierParameters}
        {@in List<URI> credentialIds}
        {@in List<URI> pseudonymIds}
        {@in List<Attribute> selfClaimedAttributes}
      }
      This method does the first step in an issuance proof, namely it creates the presentation 
      token required for an advanced issuance protocol. For subsequent steps, issuanceStep() must be called.
%       For ``simple issuance'', the verifier parameters will be NULL, and all three lists empty.
      \end{method}
      
      \begin{method}
%       IssuMsgOrCredDesc issuanceStep(IssuanceMessage issuanceMessage)
      {IssuanceMessage or CredentialDescription}
      {issuanceStep}
      {
        {@in IssuanceMessage im}
      }
      This method continues the issuance protocol. The number of issuance rounds depends on the signature 
      technology and it is set by each implementation of the signature building block individually.
      \end{method}
      
      \begin{method}
%       IssuancePolicy extractIssuancePolicy(IssuanceMessage issuanceMessage)
      {IssuancePolicy}
      {extractIssuancePolicy}
      {
        {@in IssuanceMessage im}
      }
      Extracts the issuance policy from the given issuance message.
      \end{method}

  
  \paragraph{Prover Crypto Engine}

      \begin{method}
%       PresentationToken createPresentationToken(
%       PresentationTokenDescription presentationTokenDescription,
%       VerifierParameters verifierParameters, List<URI> credentialUris, List<URI> pseudonymUris)
      {PresentationToken}
      {createPresentationToken}
      {
        {@in PresentationTokenDescription ptd}
        {@in VerifierParameters}
        {@in List<URI> credentialIds}
        {@in List<URI> pseudonymIds}
      }
      This method asks the crypto engine to conduct a presentation proof.
      \end{method}
      
% TODO This method is currently not implemented. It should be ;-)
%       \begin{method}
%       {String}
%       {describePresentationToken}
%       {
%         {@in PresentationTokenDescription ptd}
%         {@in VerifierParameters}
%         {@in List<URI> credentialUris}
%         {@in List<URI> pseudonymUris}
%       }
%       This method generates a description of the proof that createPresentationToken() would create. This description
%       is intended to be shown in the user interface.
%       \end{method}
      
      \begin{method}
%       Credential updateNonRevocationEvidence(Credential credential, @Nullable URI versionOfNre,
%       boolean allowLinkableUpdate)
      {Credential}
      {updateNonRevocationEvidence}
      {
        {@in Credential credential}
        {@in @Nullable URI versionOfNre \textrm{\textit{/* If null: latest version*/}}}
        {@in boolean allowLinkableUpdate}
      }
      This method updates the non-revocation evidence in the credential to the specified version
      (or the latest version if none is specified). This method MAY refuse to update to an earlier
      version of the NRE. If the allowLinkableUpdate is false, this method MUST do the update in an
      unlikable manner.
      \end{method}  
          
      \begin{method}
%       RevocationInformation updateRevocationInformation(URI raParametersId,
%       @Nullable URI revocationInformationId)
      {RevocationInformation}
      {updateRevocationInformation}
      {
        {@in URI revocationAuthorityParametersId}
        {@in @Nullable URI revocationInformationId \textrm{\textit{/* If null: latest version*/}}}
      }
      This method returns a specific version of the revocation information (or the latest version
      if none is specified).
      \end{method}
      
      \begin{method}
%       boolean isRevoked(Credential cred)
      {boolean}
      {isRevoked}
      {
        {@in Credential cred}
      }
      This method returns true in case the credential has been revoked, and false otherwise.
      \end{method}
      
      \begin{method}
%       PseudonymWithMetadata createPseudonym(URI pseudonymId, URI scope,
%       boolean isScopeExclusive, URI secretLocation)
      {PseudonymWithMetadata}
      {createPseudonym}
      {
        {@in URI pseudonymId}
        {@in URI scope}
        {@in boolean isScopeExclusive}
        {@in URI secretLocation \textrm{\emph{/* e.g., smartcard URI*/}}}
      }
      This method creates a new pseudonym with metadata as specified in~\cite{abc4trust:h22}.
      \end{method}
      
% TODO This method is currently not there - however, the secret generation should be possible 
% also in a standalone version of the library.
%       \begin{method}
%       {Secret}
%       {createSecret}
%       {
%         {@in URI secretUriPrefix}
%       }
%       This method creates a new secret (also known as ``software smartcard'', since to the verifier,
%       it is indistinguishable from a hardware smartcard).
%       \robert{I believe that this function should be moved somewhere else, for example the smartcard manager.}
%       \end{method}
      
      
      



  \subsubsection{Verifier's Crypto Engine}
  
      \begin{method}
%       boolean verifyToken(PresentationToken presentationToken,
%       VerifierParameters verifierParameters)
      {boolean}
      {verifyToken}
      {
        {@in PresentationToken pt}
        {@in VerifierParameters vp}
      }
      This method verifies the given presentation token.
      \end{method}
      
      \begin{method}
%       RevocationInformation updateRevocationInformation(URI raParametersId,
%       @Nullable URI revocationInformationId)
      {RevocationInformation}
      {updateRevocationInformation}
      {
        {@in URI revocationAuthorityParametersId}
        {@in @Nullable URI revocationInformationId \textrm{\textit{/* If null: latest version*/}}}
      }
      This method returns a specific version of the revocation information (or the latest version
      if none is specified).
      \end{method}
      
      \begin{method}
      {VerifierParametersTemplate}
      {generateVerifierParameterConfigurationTemplate}
      {
      }
      This method generates a template for the verifier parameter configuration.
      This template will have to be filled out manually, and then given to generateVerifierParameters().
      \end{method}
      
      \begin{method}
%       VerifierParameters generateVerifierParameters(
%       VerifierParametersTemplate verifierParametersTemplate)
      {VerifierParameters}
      {generateVerifierParameters}
      {
        {@in VerifierParametersTemplate verifierParametersTemplate}
      }
      This method generates verifier parameters based on the given configuration.
      \end{method}
      
      
      



  \subsubsection{Issuer's Crypto Engine}

      \begin{method}
%       IssuanceMessageAndBoolean initializeIssuance(IssuancePolicy issuancePolicy,
%       List<Attribute> issuerProvidedAttributes, @Nullable URI context)
      {IssuanceMessageAndBoolean}
      {initializeIssuance}
      {
        {@in IssuancePolicy ip}
%         {@in VerifierParameters}
        {@in List<Attribute> issuerProvidedAttributes}
        {@in @Nullable context}
      }
      This method does the first step in an issuance proof. For subsequent steps, continueIssuance() must be called.
      If the provided context is NULL, the context will be generated at random (and be set inside the issuance message).

      This method also returns true if this is the last message of the issuance.
      This method also returns the URI of the log entry that was stored during the issuance protocol.
      \end{method}
      
      \begin{method}
%       IssuanceMessageAndBoolean issuanceStep(IssuanceMessage issuanceMessage)
      {IssuanceMessageAndBoolean}
      {issuanceStep}
      {
        {@in IssuanceMessage im}
      }
      This method continues the issuance proof and returns true if this is
      the last message of the issuance.
      This method also returns the URI of the log entry that was stored during the issuance protocol.
      \end{method}
      
      \begin{method}
%       IssuanceTokenDescription extractIssuanceTokenDescription(IssuanceMessage issuanceMessage)
      {@Nullable IssuanceTokenDescription}
      {extractIssuanceTokenDescription}
      {
        {@in IssuanceMessage im}
      }
      This method looks for an IssuanceTokenDescription inside the issuance message. It returns the issuance token, or
      NULL if none could be found.
      It is guaranteed that this method returns a non-null value before a new credential is actually issued, so that the
      upper layers may abort the issuance protocol if a certain condition is not satisfied (such as the absence of a registered pseudonym).
      \end{method}
      
      \begin{method}
%       IssuanceTokenAndIssuancePolicy extractIssuanceTokenAndPolicy(
%       IssuanceMessage issuanceMessage)
      {@Nullable IssuanceTokenAndIssuancePolicy}
      {extractIssuanceTokenAndPolicy}
      {
        {@in IssuanceMessage im}
      }
      This method looks for an IssuanceToken and an IssuancePolicy inside the issuance message. It returns those elements, or
      NULL if none could be found.
      \end{method}

% TODO maybe we should add this to the issuer's crypto engine?
% In any case the verifier and the prover both have the same code (maybe we should use an orchestration object for that?)      
%       \begin{method}
%       {RevocationInformation}
%       {updateRevocationInformation}
%       {
%         {@in URI revocationAuthority}
%         {@in @Nullable URI versionOfNre \textrm{\textit{/* If null: latest version*/}}}
%         {@in @Nullable RevocationInformation currentRevocationInformation}
%       }
%       This method returns a specific version of the revocation information (or the latest version
%       if none is specified). You may provide the current revocation information to enable a quicker update.
%       \end{method}

      \begin{method}
%       SystemParametersTemplate createSystemParametersTemplate()
      {SystemParametersTemplate}
      {createSystemParametersTemplate}
      {
      }
      This method generates a template for the system parameter configuration.
      This template will have to be filled out manually, and then given to setupSystemParameters().
      \end{method}
      
      \begin{method}
%       SystemParameters setupSystemParameters(SystemParametersTemplate systemParametersTemplate)
      {SystemParameters}
      {setupSystemParameters}
      {
        {@in SystemParametersTemplate spt}
      }
      This method generates system parameters based on the given configuration.
      \end{method}
      
      \begin{method}
%       IssuerPublicKeyTemplate createIssuerKeyPairTemplate()
      {IssuerPublicKeyTemplate}
      {createIssuerKeyPairTemplate}
      {
      }
      This method generates a template for the issuer key pair configuration.
      This template will have to be filled out manually, and then given to setupIssuerKeyPair().
      \end{method}
      
      \begin{method}
%       KeyPair setupIssuerKeyPair(SystemParameters systemParameters,
%       IssuerPublicKeyTemplate issuerParametersTemplate)
      {KeyPair}
      {setupIssuerKeyPair}
      {
        {@in SystemParameters sp}
        {@in IssuerPublicKeyTemplate ipt}
      }
      This method generates the issuer key pair based on the given configuration.
      \end{method}
      
      \begin{method}
%       VerifierParametersTemplate createVerifierParametersTemplate() 
      {VerifierParametersTemplate}
      {createVerifierParametersTemplate}
      {
      }
      This method generates a template for the verifier parameter configuration.
      This template will have to be filled out manually, and then given to setupVerifierParameters().
      \end{method}
      
      \begin{method}
%       VerifierParameters setupVerifierParameters(
%       VerifierParametersTemplate verifierParametersTemplate)
      {VerifierParameters}
      {setupVerifierParameters}
      {
        {@in VerifierParametersTemplate vpt}
      }
      This method generates verifier parameters based on the given configuration.
      \end{method}
  
      
      



  \subsubsection{Inspector's Crypto Engine}
      
      \begin{method}
%       public List<Attribute> inspect(PresentationToken presentationToken) 
      {List<Attribute>}
      {inspect}
      {
        {@in PresentationToken pt}
      }
      Inspects a presentation token.
      \end{method}
      \begin{method}
%       List<Attribute> inspect(IssuanceToken issuanceToken) 
      {List<Attribute>}
      {inspect}
      {
        {@in IssuanceToken it}
      }
      Inspects an issuance token.
      \end{method}
      \begin{method}
%       InspectorPublicKeyTemplate createInspectorPublicKeyTemplate()
      {InspectorPublicKeyTemplate}
      {createInspectorPublicKeyTemplate}
      {
      }
      This method generates a template for the inspector's key pair configuration.
      This template will have to be filled out manually, and then given to generateKeyPair().
      \end{method}
      \begin{method}
%       KeyPair setupInspectorKeyPair(SystemParameters systemParameters,
%       InspectorPublicKeyTemplate template)
      {KeyPair}
      {setupInspectorKeyPair}
      {
        {@in SystemParameters sp}
        {@in InspectorPublicKeyTemplate ipt}
      }
      This method generates the inspector's key pair based on the given configuration.
      \end{method}

\robert{Do we need interfaces to prove that an inspection was done properly (with a zero-knowledge proof)?}
 
      
      



  \subsubsection{Revocation Authority's Crypto Engine}
      
      \begin{method}
%       NonRevocationEvidence newRevocationHandle(URI raParametersId,
%       URI nonRevocationEvidenceId, List<Attribute> attributes)
      {NonRevocationEvidence}
      {newRevocationHandle}
      {
        {@in URI revocationAuthorityParamtersId}
      }
      This method is intended to be called though the revocation proxy. This method generates
      a new revocation handle and the corresponding non-revocation evidence.
      This method additionally returns the URI of the latest revocation information.
      \end{method}
      
      \begin{method}
%       RevocationInformation updateRevocationInformation(URI raParametersUID,
%       @Nullable URI revocationInformationUID,
%       @Nullable RevocationInformation currentRevocationInformation)
      {RevocationInformation}
      {updateRevocationInformation}
      {
        {@in URI revocationAuthorityParametersId}
        {@in @Nullable URI revocationInformationId \textrm{\textit{/*If null: latest version*/}}}
%         {@in @Nullable RevocationInformation currentRI}
      }
      This method is intended to be called through the revocation proxy. This method returns
      a specific version of the revocation information.
      \end{method}

%       \begin{method}
%       {NreUpdateResponse}
%       {updateNonRevocationEvidence}
%       {
%         {@in URI revocationAuthorityUri}
%         {@in @Nullable URI previousVersionOfNRE \textrm{\textit{/*If null: don't update; generate new*/}}}
%         {@in @Nullable URI versionOfNRE \textrm{\textit{/*If null: latest version*/}}}
%         {@in NreUpdateRequest request}
%       }
%       This method is intended to be called through the revocation proxy. This method helps the caller
%       update a non revocation evidence to a specific version (or the latest version).
%       The structure of the request and the return value are implementation-specific.
%       \end{method}
      
      \begin{method}
%       URI revoke(URI revocationAuthorityId, BigInt revocationHandleValue)
      {URI}
      {revoke}
      {
        {@in URI revocationAuthorityParametersId}
        {@in BigInt revocationHandle}
      }
      This method revokes the specified revocation handle, and returns the URI of the latest
      revocation information.
      \end{method}
      
      \begin{method}
%         RevocationHistory getRevocationHistory(URI raParametersId)
      {RevocationHistory}
      {getRevocationHistory}
      {
        {@in URI revocationAuthorityParametersId}
      }
      Returns the revocation history.
      \end{method}
      
      \begin{method}
%       RevocationAuthorityPublicKeyTemplate createRevocationAuthorityPublicKeyTemplate()
      {RevocationAuthorityPublicKeyTemplate}
      {createRevocationAuthorityPublicKeyTemplate}
      {
      }
      This method generates a template for the revocation authority's key pair configuration.
      This template will have to be filled out manually, and then given to setupRevocationAuthorityKeyPair().
      \end{method}
      
      \begin{method}
%       KeyPair setupRevocationAuthorityKeyPair(SystemParameters systemParameters,
%       RevocationAuthorityPublicKeyTemplate template)
      {KeyPair}
      {setupRevocationAuthorityKeyPair}
      {
        {@in SystemParameters sp}
        {@in RevocationAuthorityPublicKeyTemplate rapt}
      }
      This method generates the revocation authority's key pair based on the given configuration.
      \end{method}
      
     
