%!TEX root =  IdmxSpecification.tex

  \subsection{Common Interfaces}
  \label{sec:blocks:common}
  In this section, we describe the interfaces that are shared by most
  building blocks. Certain blocks require system parameters, keys, or verifier
  parameters to function; here we describe the interface through which these
  blocks can generate these parameters and keys. Building blocks that take part
  in a zero-knowledge proof have one or several proof interfaces (ZkModules).

    \subsubsection{Interface for all building blocks}
    \label{sec:intf:all}
    All general building blocks must implement the following method:
      \begin{getter}{URI}{getBuildingBlockId}
      Returns the name of the building block.
      This name should start with \identifier{}.
      For example, the signature building block will have the building block 
      id: \identifier{sig}.
      \end{getter}
    \subsubsection{Interface for all implementation building blocks}
    \label{sec:intf:major}
%     All major building blocks must contain the following abstract method:
      \begin{getter}{URI}{getImplementationId}
      Returns the name of the current implementation of the building block.
      This name should start with the identifier of a block and adds the
      appropriate suffix for this implementation. For example, the CL signature
      building block extending the general signature building block will
      have the implementation id: \identifier{sig:cl}.
      \end{getter}


    \subsubsection{System parameter generator}
    \label{sec:intf:syspargen}
    System parameters must be generated before the system is deployed, and
    should be distributed to all clients in the system.
    System parameters are generated in several steps. 
    First, a template of a configuration file is generated. 
    This template consists of a list of fields together with a description. 
    Each building block that implements the
    system parameter interface may contribute to this list of fields.
    Second, the client has to specify a value for each of the fields
    in the configuration template, thus creating a configuration file.
    Third, the configuration file is parsed by all the building
    blocks that contributed to the configuration template, 
    and a list of system parameters is created based on
    the configuration file.

    Building blocks that need to create their own system parameters must implement
    the following methods:
      \begin{method}
      {void}
      {generateSystemParameterConfigurationTemplate}{{@inout Set<FieldDescription> configurationFileTemplate}}
      This method may add fields (and a human friendly description) to the system parameter configuration file.
      \end{method}
      \begin{method}
      {void}
      {generateSystemParameters}
      {
        {@in Map<FieldDescription, Value> configurationFile}
        {@inout Map<Field, Value> systemParameters}
      }
      This method generates system parameters based on the configuration file provided by the user.
      The method should only read fields in the configuration file that it added with the
      function generateSystemParameterConfigurationTemplate earlier.
      \end{method}

    \subsubsection{Key pair generator}
    \label{sec:intf:keygen}
    Key pairs are generated by each issuer, each revocation authority, and each inspector in the
    system. The public key of that pair must be distributed to all clients before they are able
    to interact with the entity which generated the key pair.
    Key pairs are generated in a manner similar to the system parameters:
    first a configuration template is generated by the entity wishing to generate a key pair,
    second the template is completed (manually) by the entity to yield the configuration file, third the
    configuration file is parsed and the key pair is generated.

    Building blocks that need to generate a key pair must implement the following methods:
      \begin{getter}{Set<FieldDescription>}{generateKeyPairConfigurationTemplate}
      This method generates the key pair parameter configuration template (which consists of a list of
      field names and their human friendly descriptions).
      \end{getter}
      \begin{method}
      {KeyPair}
      {generateKeyPair}
      {
        {@in Map<Field, Value> systemParameters}
        {@in Map<FieldDescription, Value> configurationFile}
      }
      This method generates a key pair (consisting of a public key and a secret key)
      based on the configuration file provided by the user and the
      current system parameters.
      \end{method}

    \subsubsection{Verifier parameter generator}
    \label{sec:intf:verpargen}
    Verifier parameters may be generated by each verifier in the system, and are
    transmitted to the prover together with the policy.
    Verifier parameters are generated in a manner similar to the system parameters and key pairs:
    first a configuration template is generated by the verifier, second it is
    completed (manually) by the verifier to yield the configuration file, third the
    configuration file is parsed and the verifier parameters are generated.

    Building blocks that need to create verifier parameters must implement the
    following methods:
      \begin{method}{void}{generateVerifierParameterConfigurationTemplate}{{@inout Set<FieldDescription> configurationFileTemplate}}
      This method may add fields (and a human friendly description) to the verifier parameter configuration file.
      \end{method}
      \begin{method}
      {void}
      {generateVerifierParameters}
      {
        {@in Map<Field, Value> systemParameters}
        {@in Map<FieldDescription, Value> configurationFile}
        {@inout Map<Field, Value> verifierParameters}
      }
      This method generates verifier parameters based on the configuration file provided by the user and the
      current system parameters.
      The method should only read fields in the configuration file that it added with the
      function generateVerifierParameterConfigurationTemplate earlier.
      \end{method}

    \subsubsection{Proof Interface}
    \label{sec:intf:proof}
    All building blocks that participate in a zero-knowledge proof must implement the following
    tuple of ZkModule factories (ZkModule-generating methods); these ZkModules are used as input
    to the proof engine.
    Building blocks that have several proof interfaces will
    implement several of these triples, each one with a different suffix \texttt{\emph{XXX}}.
    Building blocks may freely choose the arguments of the methods below (however in order to
    guarantee an implementation-agnostic code, different implementations
    of the same building block must have exactly the same method names and arguments).
      \begin{method}
      {ZkModuleProver}
      {getZkModuleProver\emph{XXX}}
      {
        {\textrm{\textit{Each building block can choose the arguments of this method}}}
      }
      This method create a new ZkModuleProver object. This object: (1) encapsulates the state of the current
      building block implementation that is needed for
      generating a zero-knowledge proof; and (2) exposes a unified interface to the proof engine.
      We describe ZkModuleProver in more detail below.
      \end{method}
      \begin{method}
      {ZkModuleVerifier}
      {getZkModuleVerifier\emph{XXX}}
      {
        {\textrm{\textit{Each building block can choose the arguments of this method}}}
      }
      This method create a new ZkModuleVerifier object. This object: (1) encapsulates the state of the current
      building block implementation that is needed for
      verifying a zero-knowledge proof; and (2) exposes a unified interface to the proof engine.
      We describe ZkModuleVerifier in more detail below.
      \end{method}
      % \begin{method}
      % {ZkModuleDescriber}
      % {getZkModuleDescriber\emph{XXX}}
      % {
        % {\textrm{\textit{Each building block can choose the arguments of this method}}}
      % }
      % This method create a new ZkModuleDescriber object. This object: (1) encapsulates the state of the current
      % building block implementation that is needed for
      % describing a zero-knowledge proof; and (2) exposes a unified interface to the proof engine.
      % We describe ZkModuleDescriber in more detail below.
      % \end{method}

    \subsubsection{ZkModules}
    ZkModuleProver and ZkModuleVerifier are abstract classes that expose a unified interface to
    the proof engine for conducting Fiat-Shamir zero-knowledge proofs and verifying them.
    The concrete instantiation of these modules encapsulate implementation specific state.

    All three ZkModules must implement the following methods:
    \begin{getter}
    {String}
    {getIdentifier}
    Returns the unique identifier of this instance. This identifier can be freely chosen at runtime,
    must be unique throughout the proof, and
    it must be guaranteed that the prover and the verifier agree on the same identifier.
    \end{getter}
    \begin{getter}
    {String}
    {getBuildingBlockId}
    Returns the name of the building block that generated this instance.
    This name should start with \identifier{b:}.
    \end{getter}
    \begin{getter}
    {String}
    {getImplementationId}
    Returns the name of the specific implementation of the building block that generated this instance.
    For major building blocks (which admit more than one implementation), this name should start with \identifier{i:}.
    For building blocks which admit only one implementation, the return value
    must be the same as for getBuildingBlockId().
    \end{getter}


    \paragraph{ZkModuleProver}
%     \subsubsubsection{ZkModuleProver}
    \label{sec:intf:zkmoduleprover}
    When a proof is being conducted, each of the following methods will be called (in the order
    given below) on each of the ZkModuleProver participating in the proof.
    In all of these method calls, the ZkModuleProver is given a reference to ZkBuilder with
    which it is supposed to interact. The ZkBuilder is responsible for centralizing the
    actions of all ZkModules.
    (We note here that there is exactly one ZkBuilder that is active during the proof, and that
    the ZkModuleProver is given a reference to a ``firewalled'' version of the former, which restricts the
    methods that can be called).
    \begin{method}
    {void}
    {initializeModule}
    {
      {@ref ZkBuilderStateInitialize zkBuilder}
    }
    Notify the zkBuilder of all attributes (including temporary variables) that it will use during the proof.
    Notify the zkBuilder which attribute values this ZkModule requires from other ZkModules, and which attribute values this ZkModule
    will provide for other ZkModules (the modules will be topologically sorted after this function call).
    The method may declare that an attribute is to be revealed, or that two attributes are equal.

    The ZkBuilderStateInitialize ``firewall'' allows the following methods to be called on the zkBuilder:
      \begin{itemize}
      \item void registerAttribute(String name, Range r, boolean isExternal)---indicates that this module will use the
       given attribute during the proof.
       The module must specify the range of acceptable values for this attibutes, to assist the proof engine in
       choosing an R-value (see §\ref{zkproof:terminology}) of the correct size.
       The isExternal flag is used for attributes that are on external devices (such as
       smartcards).
      \item void requiresAttributeValue(String name)---indicates that this module needs to know the value of the given attribute
       in the collectAttributesForProof() function. Modules will be topologically sorted to guarantee that this value is available.
      \item void providesAttributeValue(String name)---indicates that this module will provide the value of the given attribute
       later, namely when the module is called again though the collectAttributesForProof() function
       (using the attribute values it required with requiresAttributeValue).
       In case of circular dependency an error is raised. If this
       module knows the value of the attribute now already, it should call setValueOfAttribute
       immediately instead.
      \item void attributeIsRevealed(String name)---indicates that the given attribute must be revealed by the proof engine.
      \item void attributesAreEqual(String attributeName1, String attributeName2)---indicates that the given attribute are
        to be treated as one and the same by the proof engine. This method will fail if an external and a non-external attribute
        are passed as arguments.
      \item void attributeLinearCombination(String attributeName1, BigInteger constant, List<StringAndBigInteger> attributeAndMultiplier)---
        indicates that the given attribute is equal to a linear combination of the attributes in the list plus a constant.
        The proof engine will choose the R-values of all attributes accordingly. In case of a circular dependency,
        an error is raised.
      \item void setValueOfAttribute(String name, BigInteger value, ResidueClass rc)---sets the value of the given attribute, so that the
        proof engine can share this value with other modules. The residue class informs the proof engine
        whether the attribute is: (1) an integer in the range 0...q (where q is the subgroup order),
        (2) any integer, (3) a value modulo q, (4) a value modulo another value, or (5) unspecified.
        This information is used by the range proof module to decide whether it is necessary
        to conduct a proof that the attribute is larger than 0 or smaller than q.
        If multiple residue classes are specified (even across blocks), then the
        proof engine will intelligently combine the choices.
      \item void markAsSignatureBuildingBlock()---marks the current ZkModule as being a signature
      building block. This is important when computing the challenge: indeed the hash
      contribution of the first signature
      building block is treated specially in order to guarantee compatibility with the U-Prove
      specification.
      \item DeviceProofSpecification getDeviceProofSpecification()---returns an object that
      the ZkModule can use to ask the external device (smartcard) to do a certain zero-knowledge proof.
      \end{itemize}
    \end{method}
    \begin{method}
    {void}
    {collectAttributesForProof}
    {
      {@ref ZkBuilderStateCollect zkBuilder}
    }
    For all attributes for which this module called providesAttributeValue(), this method
    must provide the value of that attribute to the ZkBuilder. This module may query the attribute
    value for all attributes for which this method called requiresAttributeValue().
    (The modules were topologically sorted prior to this function being called.)

    The ZkBuilderStateCollect ``firewall'' allows the following methods to be called on the zkBuilder:
      \begin{itemize}
      \item boolean isRevealedAttribute(String name)
      \item BigInteger getValueOfAttribute(String name)---may only call this method if requiresAttributeValue() has been
       called in the previous round on the same attribute.
      \item void setValueOfAttribute(String name, BigInteger value, ResidueClass rc)---you must call this method for all attributes
        for which you called providesAttributeValue() in the previous round.
      \item ResidueClass getResidueClassOfAttribute(String name)
      \item DeviceProofSpecification getDeviceProofSpecification()
      \end{itemize}
    \end{method}
    \begin{method}
    {void}
    {firstRound}
    {
      {@ref ZkBuilderStateFirst zkBuilder}
    }
    Ask the builder which attributes are revealed (and recover their value) and
    which attributes are unrevealed (and recover the R-value (randomizer) associated with the attribute).
    Generate T-values (first message of a $\Sigma$-protocol, see §\ref{zkproof:terminology}) for each equations, generate D-values (values delivered to the verifier),
    register N-values (context values that both the prover and verifier know, see §\ref{zkproof:terminology}), and
    generate nonce commitments. Send these to the builder.

    The ZkBuilderStateFirst ``firewall'' allows the following methods to be called on the zkBuilder:
      \begin{itemize}
      \item boolean isRevealedAttribute(String name)
      \item boolean isValueOfAttributeAvailable(String name)
      \item BigInteger getValueOfAttribute(String name)
      \item ResidueClass getResidueClassOfAttribute(String name)
      \item BigInteger getRValueOfAttribute(String name)
      \item GroupElement getDValueAsGroupElement(String name)---at this stage, this method may only be called for
        D-values (values delivered to the verifier, see §\ref{zkproof:terminology}) that were generated by any of the (transitive closure) of the children of the top-level module
        this module belongs to, and only if the top-level module guarantees that the D-value has already been
        added at the point this method is called. This is because 1) the proof engine does not provide any guarantees
        on the order in which the top-level modules get called, and 2) the D-value must be available before this
        method is called.
      \item void addDValueAsGroupElement(String name, GroupElement value)
      \item void addDValueAsObject(String name, byte[] value, byte[] hashContribution)
      \item void addNValue(String name, byte[] hashContribution)
      \item void addTValueForEquation(String name, GroupElement tValue)
      \item void setHashContributionOfBuildingBlock(byte[] hashContribution)---Manually set the
      hash contribution of the building block instead of letting it be computed by
      the proof engine based on the T-,D-,and N-value and the revealed attributes. Use with caution.
      \item DeviceProofCommitment getDeviceProofCommitment()---Obtain the T-values computed by
      the external devices (smartcards).
      \end{itemize}
    \end{method}
    \begin{method}
    {void}
    {secondRound}
    {
      {@ref ZkBuilderStateSecond zkBuilder}
    }
    Recover the value of the nonce commitments, and the challenge from the zkBuilder.
    Generate the S-value (third message of a $\Sigma$-protocol, see §\ref{zkproof:terminology}) for all external attributes, and send
    them to the builder.

    The ZkBuilderStateSecond ``firewall'' allows the following methods to be called on the zkBuilder:
      \begin{itemize}
      \item BigInteger getChallenge()
      \item boolean isRevealedAttribute(String name)
      \item boolean isValueOfAttributeAvailable(String name)
      \item BigInteger getValueOfAttribute(String name)
      \item ResidueClass getResidueClassOfAttribute(String name)
      \item BigInteger getRValueOfAttribute(String name)
      \item GroupElement getDValueAsGroupElement(String name)
      \item byte[] getDValueAsObject(String name)
      \item void setSValueForAttribute(String name, BigInteger sValue)---Ideally this function should be called
        for external attributes only (e.g., attributes on smartcards).
      \item DeviceProofResponse getDeviceProofResponse()---Obtain the S-values computed
      by the external devices (smartcards).
      \end{itemize}
    \end{method}

\paragraph{ZkModuleVerifier}
%     \subsubsubsection{ZkModuleVerifier}
    \label{sec:intf:zkmoduleverifier}
    When a proof is being verified, each of the following methods will be called (in the order
    given below) on each of the ZkModuleVerifier participating in the proof verification.
    In all of these method calls, the ZkModuleVerifier is given a reference to a ZkVerifier with
    which it is supposed to interact. The ZkVerifier is responsible for centralizing the
    actions of all ZkModules.
    (We note here that there is exactly one ZkVerifier that is active during the proof, and that
    the ZkModuleVerifier is given a reference to a ``firewalled'' version of the former, which restricts the
    methods that can be called).
    \begin{method}
    {void}
    {collectAttributesForVerify}
    {
      {@ref ZkVerifierStateCollect zkVerifier}
    }
    Notify the zkVerifier of all attributes (including temporary variables) that will be used during the proof.
    The method may declare that an attribute is to be revealed, that two attributes are equal, or enforce
    a particular value of an attribute.

    The ZkVerifierStateCollect ``firewall'' allows the following methods to be called on the zkBuilder:
      \begin{itemize}
      \item void registerAttribute(String name, Range r, boolean isExternal)
      \item void attributeIsRevealed(String name)
      \item void setResidueClassOfAttribute(String name, ResidueClass rc)
      \item void enforceValueOfAttribute(String name, BigInteger value)
      \item void attributesAreEqual(String attributeName1, String attributeName2)
      \item void attributeLinearCombination(String attributeName1, BigInteger constant, List<StringAndBigInteger> attributeAndMultiplier)
      \item byte[] getDValueAsObject(String name)
      \end{itemize}
    \end{method}
    \begin{method}
    {boolean}
    {verify}
    {
      {@ref ZkBuilderStateFirst zkBuilder}
    }
    Ask the zkVerifier which attributes are revealed (and recover their value) and
    which attributes are unrevealed (and recover their S-value), recover D-values,
    recover the challenge.
    Re-compute the T-values for each equation, check the hash contribution of the D-values,
    and perform implementation specific-checks.
    Return false if any of the implementation-specific checks fail.

    The ZkBuilderStateFirst ``firewall'' allows the following methods to be called on the zkBuilder:
      \begin{itemize}
      \item BigInteger getSValueOfAttribute(String name)
      \item GroupElement getDValueAsGroupElement(String name)
      \item byte[] getDValueAsObject(String name)
      \item boolean isRevealedAttribute(String name)
      \item BigInteger getValueOfRevealedAttribute(String name)
      \item void checkValueOfAttribute(String name, BigInteger value)
      \item ResidueClass getResidueClassOfAttribute(String name)
      \item BigInteger getChallenge()
      \item void checkHashContributionOfBuildingBlock(byte[] hashContribution)---Use only if
        the prover set a custom hash contribution.
      \item void checkHashContributionOfDValue(String name, byte[] hashContribution)---This method must
        be called for each non-integer D-value in the proof, otherwise an error is raised.
      \item void checkNValue(String name, byte[] hashContribution)---This method must be called for
        each N-value that was added to the proof, otherwise an error is raised.
      \item void checkHashContributionOfDValue(String name, byte[] hashContribution)---This method
        must be called for each D-Value that has a custom hash contribution.
      \item void checkTValue(String name, GroupElement tValue)---This method must be called
        for each T-value in the proof, otherwise an error is raised.
      \end{itemize}
    \end{method}


% \item[ZkModuleDescriber]
% %     \subsubsubsection{ZkModuleDescriber}
%     When a proof is being described, each of the following methods will be called (in the order
%     given below) on each of the ZkModuleDescriber participating.
%     In all of these method calls, the ZkModuleDescriber is given a reference to ZkDescriber with
%     which it is supposed to interact. The ZkDescriber is responsible for centralizing the
%     actions of all ZkModules.
%     (We note here that there is exactly one ZkDescriber that is active during the proof, and that
%     the ZkModuleDescriber is given a reference to a ``firewalled'' version of the former, which restricts the
%     methods that can be called).
%     \begin{method}
%     {void}
%     {initializeForDescribe}
%     {
%       {@ref ZkDescriberStateInitialize zkDescriber}
%     }
%     This method is identical to the corresponding method of ZkModuleProver, except that
%     this module may also register ``human friendly'' attribute values.
% 
%     The ZkDescriber allows also the following function to be called:
%     \begin{itemize}
%       \item void setHumanFriendlyValueOfAttribute(String name, String humanFriendlyValue)
%     \end{itemize}
%     \end{method}
%     \begin{method}
%     {void}
%     {collectAttributesForDescribe}
%     {
%       {@ref ZkDescriberStateCollect zkDescriber}
%     }
%     This method is identical to the corresponding method of ZkModuleProver, except that
%     this module may also register ``human friendly'' attribute values.
% 
%     The ZkDescriber allows also the following function to be called:
%     \begin{itemize}
%       \item void setHumanFriendlyValueOfAttribute(String name, String humanFriendlyValue)
%     \end{itemize}
%     \end{method}
%     \begin{method}
%     {void}
%     {describeProof}
%     {
%       {@ref ZkDescriberStateDescribe zkDescriber}
%       {@inout ProofDescription description}
%     }
%     Ask the builder which attributes are revealed (and recover their value) and
%     which attributes are unrevealed.
%     Modifies the given proof description to add what the corresponding zkModuleProver does in the proof.
% 
%     The ZkBuilderStateDescribe ``firewall'' allows the following methods to be called on the zkBuilder:
%       \begin{itemize}
%       \item boolean isRevealedAttribute(String name)
%       \item boolean isValueOfAttributeAvailable(String name)
%       \item BigInteger getValueOfAttribute(String name)
%       \item @Nullable String getHumanFriendlyValueOfAttribute(String name)
%       \item Range getRangeOfAttribute(String name)
%       \end{itemize}
%     \end{method}

